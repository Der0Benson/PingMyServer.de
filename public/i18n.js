(() => {
  "use strict";

  const STORAGE_KEY = "pms.lang";
  const DEFAULT_LANG = "de";
  const SUPPORTED = new Set(["de", "en"]);

  const LOCALE_MAP = {
    de: "de-DE",
    en: "en-US",
  };

  const STRINGS = {
    de: {
      meta: {
        login: {
          title: "Login - PingMyServer",
          description: "Login zu PingMyServer f√ºr Monitoring, Vorf√§lle und Benachrichtigungen.",
        },
        onboarding: {
          title: "Onboarding ¬∑ PingMyServer",
          description: "Onboarding in PingMyServer: ersten Monitor anlegen und Monitoring starten.",
        },
        landing: {
          title: "PingMyServer - Uptime Monitoring f√ºr Websites, APIs und Services",
          description:
            "PingMyServer √ºberwacht Websites, APIs und Services rund um die Uhr. Erhalte Ausfall-Alerts per Discord, E-Mail und Webhook in Sekunden.",
          og_title: "PingMyServer - Uptime Monitoring f√ºr Websites, APIs und Services",
          og_description: "Uptime-Monitoring f√ºr Websites, APIs und Services mit schnellen Alerts und √∂ffentlicher Statusseite.",
          twitter_title: "PingMyServer - Uptime Monitoring",
          twitter_description: "√úberwache Websites und APIs 24/7 und erhalte Alerts in Sekunden.",
        },
        app: {
          title: "Dashboard ¬∑ PingMyServer",
          description: "Dashboard von PingMyServer f√ºr Monitoring, Uptime-Verlauf und Alarmierung.",
        },
        monitors: {
          title: "Monitore ¬∑ PingMyServer",
          description: "Monitore verwalten: Domains, Projekte und API-Endpunkte.",
        },
        incidents: {
          title: "Vorf√§lle ¬∑ PingMyServer",
          description: "Vorfalls√ºbersicht in PingMyServer mit Verlauf und Ausfalldetails.",
        },
        notifications: {
          title: "Benachrichtigungen ¬∑ PingMyServer",
          description: "Benachrichtigungskan√§le in PingMyServer konfigurieren und verwalten.",
        },
        connections: {
          title: "Connections ¬∑ PingMyServer",
          description: "Verbindungen und Integrationen in PingMyServer verwalten.",
        },
        game_monitor: {
          title: "Game Monitor - PingMyServer",
          description: "Game Monitor f√ºr Minecraft: Serverstatus, Ping, Spielerzahlen und weitere Live-Metriken.",
        },
        privacy: {
          title: "Datenschutz ¬∑ PingMyServer",
          description:
            "Datenschutzerkl√§rung von PingMyServer: Informationen zur Verarbeitung, Speicherung und deinen Rechten nach DSGVO.",
          og_title: "Datenschutz ¬∑ PingMyServer",
          og_description: "Datenschutzerkl√§rung von PingMyServer.",
          twitter_title: "Datenschutz ¬∑ PingMyServer",
          twitter_description: "Datenschutzerkl√§rung von PingMyServer.",
        },
        imprint: {
          title: "Impressum ¬∑ PingMyServer",
          description: "Impressum von PingMyServer mit allen Pflichtangaben nach ¬ß 5 TMG und Kontaktinformationen.",
          og_title: "Impressum ¬∑ PingMyServer",
          og_description: "Impressum von PingMyServer.",
          twitter_title: "Impressum ¬∑ PingMyServer",
          twitter_description: "Impressum von PingMyServer.",
        },
        terms: {
          title: "Nutzungsbedingungen ¬∑ PingMyServer",
          description: "Nutzungsbedingungen von PingMyServer mit Regelungen zu Nutzung, Leistungsumfang, K√ºndigung und Haftung.",
          og_title: "Nutzungsbedingungen ¬∑ PingMyServer",
          og_description: "Nutzungsbedingungen von PingMyServer.",
          twitter_title: "Nutzungsbedingungen ¬∑ PingMyServer",
          twitter_description: "Nutzungsbedingungen von PingMyServer.",
        },
        owner: {
          title: "Owner Ops ¬∑ PingMyServer",
          description: "Owner-√úbersicht von PingMyServer f√ºr operative Kennzahlen und Top-Monitore.",
        },
        status: {
          title: "Statusseite ¬∑ PingMyServer",
          description: "Live-Statusseite von PingMyServer mit Uptime, Vorf√§llen und letzten Checks in Echtzeit.",
          og_title: "PingMyServer Statusseite",
          og_description: "Live-Statusseite mit Uptime, Vorf√§llen und letzten Checks.",
          twitter_title: "PingMyServer Statusseite",
          twitter_description: "Live-Statusseite mit Uptime und Vorf√§llen.",
        },
      },
      onboarding: {
        h1: "Welche Website willst du √ºberwachen?",
        p1: "Gib eine Domain oder URL an. Beispiele:",
        p2: "oder",
        label: {
          url: "URL oder Domain",
          name: "Name (optional)",
        },
        placeholder: {
          name: "Mein Shop",
        },
        endpoints: {
          summary: "API Endpunkte (optional)",
          hint1: "Ein Pfad pro Zeile. Beispiel:",
          hint2: "oder",
          hint3: "Tipp: fuer die Root-URL",
          hint4: "eintragen.",
          label: "Endpunkte (1 pro Zeile)",
          placeholder: "/API/Ping.php\n/API/get.php",
        },
        button: {
          create: "Monitor erstellen",
        },
        msg: {
          enter_url: "Bitte eine Domain oder URL eingeben.",
          creating: "Monitor wird erstellt...",
          creating_many: "Erstelle {count} Monitore...",
          creating_many_progress: "{done}/{total} erstellt...",
          created_redirect: "Monitor erstellt. Weiterleitung...",
          created_many_redirect: "{count} Monitore erstellt. Weiterleitung...",
        },
        error: {
          local_target_forbidden: "Lokale Ziele wie localhost sind aus Sicherheitsgr√ºnden nicht erlaubt.",
          private_target_forbidden: "Private IP-Ziele sind nicht erlaubt. Bitte den Host zur Private-Allowlist hinzuf√ºgen.",
          mixed_target_forbidden:
            "Die Domain l√∂st sowohl auf √∂ffentliche als auch private DNS-Ziele auf. Bitte MONITOR_PRIVATE_TARGET_POLICY=all_private setzen.",
          invalid_protocol: "Nur http:// oder https:// sind erlaubt.",
          invalid_url: "Die URL ist ung√ºltig. Bitte Eingabe pr√ºfen.",
          target_blocked: "Das Ziel wurde durch die Security-Policy blockiert.",
          invalid_input: "Bitte URL/Domain pr√ºfen.",
          monitor_limit_reached: "Monitor-Limit erreicht. Bitte alte Monitore l√∂schen oder Limit erh√∂hen.",
          internal_error: "Interner Fehler beim Erstellen des Monitors. Bitte sp√§ter erneut versuchen.",
          backend_503: "Backend ist aktuell nicht verf√ºgbar (HTTP 503). Bitte Server-Service neu starten.",
          proxy_502: "Proxy-Fehler zum Backend (HTTP 502). Bitte Server-Service und Apache Proxy pr√ºfen.",
          bad_request_400: "Der Webserver hat die Anfrage als ung√ºltig abgewiesen (HTTP 400).",
          forbidden_403: "Der Webserver hat die Anfrage blockiert (HTTP 403).",
          unauthorized_401: "Session ist nicht mehr g√ºltig. Bitte erneut anmelden.",
          webserver_rejected: "Die Anfrage wurde vom Webserver abgewiesen.",
          create_failed: "Monitor konnte nicht erstellt werden.",
          endpoints_too_many: "Zu viele Endpunkte. Maximal {max}.",
          endpoint_invalid: "Ungueltiger Endpoint: {value}",
          endpoint_failed: "{created}/{total} erstellt. Fehler bei {value}: {detail}",
        },
      },
      login: {
        h1: "Anmelden oder registrieren",
        sub: "GitHub-, Google- und Discord-Login sind verf√ºgbar, sobald OAuth aktiviert ist.",
        divider: "oder mit E-Mail",
        aria: {
          auth: "Authentifizierung",
        },
        mode: {
          login: "Login",
          register: "Register",
        },
        label: {
          email: "E-Mail",
          password: "Passwort",
          verification_code: "Verifizierungscode",
        },
        placeholder: {
          verification_code: "123456",
        },
        button: {
          sign_in: "Einloggen",
          create_account: "Konto erstellen",
          verify_code: "Code pr√ºfen",
          resend_code: "Code erneut senden",
          resend_code_wait: "Code erneut senden ({seconds}s)",
          back_to_login: "Zur√ºck zum Login",
        },
        verify: {
          hint_default: "Wir haben dir einen Verifizierungscode per E-Mail gesendet.",
          hint_sent: "Wir haben einen Code an {email} gesendet. G√ºltig f√ºr {seconds} Sekunden.",
        },
        msg: {
          invalid_email_password: "Bitte gib eine g√ºltige E-Mail und ein Passwort mit {min}-{max} Zeichen ein.",
          signing_in: "Einloggen ...",
          too_many_attempts: "Zu viele Versuche. Bitte sp√§ter erneut versuchen.",
          too_many_attempts_retry: "Zu viele Versuche. Bitte in {seconds} Sekunden erneut versuchen.",
          invalid_credentials: "E-Mail oder Passwort ist falsch.",
          login_failed: "Login fehlgeschlagen.",
          login_success: "Login erfolgreich. Weiterleitung ...",
          registering: "Konto wird erstellt ...",
          register_failed: "Registrierung fehlgeschlagen.",
          register_success: "Konto erstellt. Weiterleitung ...",
          verification_code_sent: "Verifizierungscode wurde gesendet. Bitte Posteingang pr√ºfen.",
          verification_code_resent: "Verifizierungscode wurde erneut gesendet.",
          verification_unavailable: "Verifizierung ist aktuell nicht verf√ºgbar. Bitte sp√§ter erneut versuchen.",
          verification_send_failed: "Verifizierungs-E-Mail konnte nicht gesendet werden. Bitte erneut versuchen.",
          verification_throttled: "Zu viele Verifizierungsanfragen. Bitte sp√§ter erneut versuchen.",
          verifying_code: "Code wird gepr√ºft ...",
          invalid_verification_code: "Bitte gib den {length}-stelligen Verifizierungscode ein.",
          invalid_verification_code_with_remaining: "Code ist ung√ºltig. Verbleibende Versuche: {remaining}.",
          verification_expired: "Verifizierung abgelaufen. Bitte erneut einloggen und neuen Code anfordern.",
          verification_attempts_exceeded: "Zu viele ung√ºltige Codes. Bitte erneut einloggen und neuen Code anfordern.",
          verification_failed: "Verifizierung fehlgeschlagen.",
          resending_code: "Verifizierungscode wird erneut gesendet ...",
          resend_cooldown: "Bitte warte {seconds} Sekunden, bevor du einen neuen Code anforderst.",
          resend_limit_reached: "Limit f√ºr erneutes Senden erreicht. Bitte erneut einloggen.",
          oauth_coming_soon: "{provider}-Login ist verf√ºgbar, sobald OAuth aktiviert ist.",
        },
        oauth: {
          default: "OAuth-Anmeldung fehlgeschlagen.",
          discord_disabled: "Discord-Login ist aktuell deaktiviert.",
          discord_denied: "Discord-Anmeldung wurde abgebrochen.",
          discord_state: "Discord-Anmeldung ist abgelaufen. Bitte erneut versuchen.",
          discord_code: "Discord-Anmeldung fehlgeschlagen (kein Code erhalten).",
          discord_token: "Discord-Token konnte nicht abgerufen werden.",
          discord_scope: "Discord hat den E-Mail-Scope nicht freigegeben. Bitte erneut autorisieren.",
          discord_profile: "Discord-Profil konnte nicht gelesen werden.",
          discord_email_missing: "Keine verifizierte E-Mail bei Discord gefunden.",
          discord_conflict: "Diese E-Mail ist bereits mit einem anderen Discord-Konto verkn√ºpft.",
          discord_error: "Discord-Anmeldung ist fehlgeschlagen. Bitte erneut versuchen.",
          github_disabled: "GitHub-Login ist aktuell deaktiviert.",
          github_denied: "GitHub-Anmeldung wurde abgebrochen.",
          github_state: "GitHub-Anmeldung ist abgelaufen. Bitte erneut versuchen.",
          github_code: "GitHub-Anmeldung fehlgeschlagen (kein Code erhalten).",
          github_token: "GitHub-Token konnte nicht abgerufen werden.",
          github_scope:
            "GitHub hat den E-Mail-Scope nicht freigegeben. Bitte App-Berechtigung entfernen und erneut anmelden.",
          github_email_permission:
            "GitHub App braucht die Berechtigung 'Email addresses: Read-only'. Bitte in GitHub App setzen und neu autorisieren.",
          github_profile: "GitHub-Profil konnte nicht gelesen werden.",
          github_email_missing: "Keine verifizierte E-Mail bei GitHub gefunden.",
          github_conflict: "Diese E-Mail ist bereits mit einem anderen GitHub-Konto verkn√ºpft.",
          github_error: "GitHub-Anmeldung ist fehlgeschlagen. Bitte erneut versuchen.",
          google_disabled: "Google-Login ist aktuell deaktiviert.",
          google_denied: "Google-Anmeldung wurde abgebrochen.",
          google_state: "Google-Anmeldung ist abgelaufen. Bitte erneut versuchen.",
          google_code: "Google-Anmeldung fehlgeschlagen (kein Code erhalten).",
          google_token: "Google-Token konnte nicht abgerufen werden.",
          google_scope: "Google hat den E-Mail-Scope nicht freigegeben. Bitte erneut autorisieren.",
          google_profile: "Google-Profil konnte nicht gelesen werden.",
          google_email_missing: "Keine verifizierte E-Mail bei Google gefunden.",
          google_conflict: "Diese E-Mail ist bereits mit einem anderen Google-Konto verkn√ºpft.",
          google_error: "Google-Anmeldung ist fehlgeschlagen. Bitte erneut versuchen.",
        },
      },
      landing: {
        nav: {
          features: "Features",
          pricing: "Preise",
          faq: "FAQ",
          status: "Statusseite",
          login: "Anmelden",
          dashboard: "Dashboard",
          cta: "Kostenlos starten",
        },
        hero: {
          badge: "Jetzt im Early Access",
          h1: {
            line1: "Ausf√§lle fr√ºh erkennen,",
            highlight: "bevor Nutzer",
            line2: "sie melden",
          },
          lead:
            "PingMyServer √ºberwacht deine Websites, APIs und Services rund um die Uhr. Erhalte sofortige Benachrichtigungen bei Ausf√§llen ‚Äì per Discord, Webhook oder E-Mail.",
          benefit: {
            setup: "Setup in unter 60 Sekunden",
            no_cc: "Keine Kreditkarte erforderlich",
            public_status: "√ñffentliche Statusseite inklusive",
          },
          cta_primary: "Early Access starten ->",
          cta_secondary: "Live-Demo ansehen",
          note: "Komplett kostenlos w√§hrend Early Access ‚Ä¢ Made in Germany",
        },
        live: {
          title: "Live Status",
          overall_loading: "Lade Monitor-Daten ...",
          monitor_loading: "Monitor wird geladen ...",
          checking: "Pr√ºfung ...",
          response_placeholder: "Response: --",
          response_value: "Response: {ms}ms",
          uptime_placeholder: "--% Uptime",
          uptime_value: "{uptime}% Uptime",
          no_monitor: "Kein Monitor verf√ºgbar",
          overall: {
            no_data: "Keine Monitor-Daten verf√ºgbar",
            operational: "Alle Systeme betriebsbereit",
            offline: {
              one: "{n} Monitor offline",
              many: "{n} Monitore offline",
            },
          },
          alert_title: "Recent Alert",
          alert_now: "gerade eben",
          alert_none: "Noch keine Vorf√§lle gefunden.",
          alert: {
            none_full: "Keine aktuellen Vorf√§lle gefunden.",
            offline: "{label} ist aktuell offline{code}",
            outage: "{label} hatte einen Ausfall{code}",
          },
        },
        social: {
          h3: "Von Entwicklern, f√ºr Entwickler",
          sub: "Ein Azubi-Projekt mit professionellem Anspruch",
          stat: {
            monitoring: "Monitoring",
            interval: "Check-Intervall",
            uptime: "Ziel-Uptime",
            made_in: "Made in Germany",
          },
        },
        features: {
          h2: "Alles, was du f√ºr professionelles Monitoring brauchst",
          lead:
            "Von einfachen HTTP-Checks bis zu komplexen API-√úberwachungen ‚Äì PingMyServer bietet alle Tools f√ºr zuverl√§ssiges Uptime-Monitoring",
          cards: {
            fast_checks: {
              title: "Blitzschnelle Checks",
              body:
                "√úberwache deine Endpoints alle 60 Sekunden. Erhalte Alerts innerhalb von Sekunden nach einem Ausfall ‚Äì bevor deine Kunden es merken.",
            },
            incident_history: {
              title: "Detaillierte Incident-Historie",
              body: "Vollst√§ndige Aufzeichnung aller Vorf√§lle mit Dauer, Fehlerquote und Verlauf. Perfekt f√ºr Postmortems und Reporting.",
            },
            alerts: {
              title: "Multi-Channel Alerts",
              body: "Discord, Slack, E-Mail, Webhooks, Telegram ‚Äì w√§hle deinen bevorzugten Kanal. Oder nutze alle gleichzeitig.",
            },
            ssl: {
              title: "SSL-Zertifikat Monitoring",
              body: "Automatische √úberwachung deiner SSL-Zertifikate. Werde rechtzeitig benachrichtigt, bevor ein Zertifikat abl√§uft.",
            },
            locations: {
              title: "Globale Monitoring-Standorte",
              body: "√úberwache deine Services von mehreren Standorten weltweit. Erkenne regionale Ausf√§lle sofort.",
            },
            public_status: {
              title: "√ñffentliche Statusseite",
              body: "Branded Statusseite f√ºr deine Kunden. Zeige Transparenz mit Echtzeit-Status und Incident-Updates.",
            },
          },
        },
        about: {
          h2: "Warum wir PingMyServer gebaut haben",
          sub: "Ein Student-Projekt mit echter Mission",
          founder_title: "Gr√ºnder & Developer",
          story: {
            p1:
              "Nach dem Gymnasium bin ich jetzt in der Ausbildung und habe nebenbei angefangen, eigene Web-Projekte zu bauen. Das Problem: Meine Seiten sind √∂fter mal ausgefallen, ohne dass ich es mitbekommen habe. Erst wenn sich Nutzer gemeldet haben, wusste ich Bescheid ‚Äì und das war mir echt peinlich.",
            p2:
              "Die bestehenden Monitoring-Tools waren entweder zu teuer f√ºr mein Azubi-Budget oder viel zu kompliziert f√ºr meine Bed√ºrfnisse. Also habe ich PingMyServer gebaut: Ein simples, zuverl√§ssiges Tool, das genau das macht, was es soll ‚Äì ohne Schnickschnack.",
            p3:
              "Jetzt will ich es mit anderen Azubis, Studenten und Developern teilen. Feedback und Verbesserungsvorschl√§ge sind herzlich willkommen!",
          },
          values: {
            open: {
              title: "Open Development",
              body: "Wir entwickeln transparent und h√∂ren auf unser Community-Feedback",
            },
            heart: {
              title: "Made with Herz",
              body: "Gebaut mit moderner Technologie und Leidenschaft f√ºrs Detail",
            },
            join: {
              title: "Join Early",
              body: "Sei dabei von Anfang an und forme die Zukunft des Tools mit",
            },
          },
          contact_prompt: "Du hast Fragen oder Feedback?",
          contact_cta: "Kontakt per E-Mail ->",
        },
        pricing: {
          h2: "Preise",
          sub: "Beta ist komplett kostenlos. Starter und Pro / Team kommen bald.",
          per_month: "/Monat",
          coming_soon: "Kommt bald",
          planned_button: "In Planung",
          beta: {
            name: "Beta",
            tagline: "Komplett kostenlos",
            per: "/w√§hrend Beta",
            features: {
              unlimited: "Unbegrenzte Monitore",
              checks_60: "60-Sekunden-Checks",
              alert_channels: "Alle Alert-Kan√§le",
              public_status: "√ñffentliche Statusseite",
              ssl: "SSL-Monitoring",
            },
            cta: "Jetzt Beta-Zugang sichern",
            no_cc: "Keine Kreditkarte erforderlich",
          },
          starter: {
            name: "Starter",
            tagline: "Geplant f√ºr sp√§ter",
            features: {
              more_monitors: "Mehr Monitore",
              checks_30: "Schnellere Checks (30s)",
              stats: "Erweiterte Statistiken",
              api: "API-Zugang",
              support: "Priority Support",
            },
          },
          pro: {
            name: "Pro / Team",
            tagline: "F√ºr sp√§ter",
            features: {
              unlimited: "Unbegrenzte Monitore",
              team: "Team-Kollaboration",
              branding: "Custom Branding",
              locations: "Dedizierte Standorte",
              support: "Premium Support",
            },
          },
          note: "Beta: kostenlos. Starter und Pro / Team: in Planung.",
        },
        faq: {
          h2: "H√§ufige Fragen",
          sub: "Alles, was du √ºber PingMyServer wissen musst",
          items: {
            private: {
              q: "Kann ich auch private Webseiten monitoren?",
              a: "Ja, aber direkte private oder lokale IP-Ziele sind aus Sicherheitsgr√ºnden blockiert. Du kannst aber HTTP-Authentifizierung nutzen oder Custom Headers setzen.",
            },
            speed: {
              q: "Wie schnell wird ein Ausfall erkannt?",
              a: "Bei 60-Sekunden-Checks (Standard) innerhalb von rund einer Minute. Bei bezahlten Pl√§nen kannst du die Check-Intervalle auf bis zu 30 Sekunden reduzieren, sodass Ausf√§lle noch schneller erkannt werden.",
            },
            share: {
              q: "Wie teile ich den Status mit Kunden?",
              a: "Jeder Monitor hat eine √∂ffentliche Statusseite, die direkt verlinkt werden kann. Die Seite zeigt Echtzeit-Status, Uptime-Statistiken und vergangene Incidents. Du kannst sie auch mit deinem eigenen Branding versehen (in bezahlten Pl√§nen).",
            },
            gdpr: {
              q: "Ist PingMyServer DSGVO-konform?",
              a: "Ja, absolut. Alle Daten werden in der EU gehostet (Frankfurt, Deutschland). Wir sammeln nur notwendige Monitoring-Daten und geben nichts an Dritte weiter. Du kannst deine Daten jederzeit exportieren oder l√∂schen.",
            },
            cancel: {
              q: "Was passiert, wenn ich k√ºndige?",
              a: "Du kannst jederzeit mit einem Klick k√ºndigen. Dein Account bleibt bis zum Ende der bezahlten Periode aktiv. Danach werden deine Monitore deaktiviert, aber deine Daten bleiben f√ºr 90 Tage gespeichert, falls du zur√ºckkommen m√∂chtest.",
            },
            api: {
              q: "Gibt es eine API?",
              a: "Ja! Ab dem Starter-Plan hast du Zugriff auf unsere REST API. Damit kannst du Monitore programmgesteuert erstellen, Status abfragen und Incidents abrufen. Perfekt f√ºr CI/CD-Integration.",
            },
          },
        },
        cta: {
          h2: "Bereit, Teil der Community zu werden?",
          p1: "Sichere dir jetzt deinen kostenlosen Beta-Zugang und hilf uns dabei,",
          p2: "das beste Uptime-Monitoring-Tool f√ºr Developer zu bauen.",
          primary: "Beta-Zugang sichern ->",
          secondary: "Statusseite ansehen",
          note: "Komplett kostenlos  ‚Ä¢  Keine Kreditkarte  ‚Ä¢  Made with Herz in Germany",
        },
        footer: {
          pitch: "Professionelles Uptime-Monitoring f√ºr Websites, APIs und Services.",
          product: "Produkt",
          api_docs: "API Docs",
          status: "Status",
          company: "Unternehmen",
          about: "√úber uns",
          commits: "Commits",
          contact: "Kontakt",
          legal: "Legal",
          terms_short: "AGB",
          gdpr: "DSGVO",
          email: "E-Mail",
        },
      },
      app: {
        dashboard: {
          current_status: "Aktueller Status",
          last_check: "Letzter Check",
          check_interval_placeholder: "Pr√ºfintervall: 1 Min.",
          check_interval: "Pr√ºfintervall: {interval}",
          waiting_first_check: "Warte auf ersten Check",
          online_for: "Online seit {duration}",
          offline_for: "Offline seit {duration}",
          last_24h: "Letzte 24 Stunden",
          uptime_placeholder: "0 Vorf√§lle, 0 Min. Ausfall",
          uptime_title: "Uptime: {uptime}%",
          summary: {
            one: "{incidents} Vorfall, {minutes} Min. Ausfall",
            many: "{incidents} Vorf√§lle, {minutes} Min. Ausfall",
          },
          last_7_days: "Letzte 7 Tage",
          last_30_days: "Letzte 30 Tage",
          last_365_days: "Letzte 365 Tage",
          choose_range: "Zeitraum w√§hlen",
          range_default: "Letzte 30 Tage",
          range_last_days: "Letzte {days} Tage",
          daily_overview: "Tages√ºbersicht.",
        },
        state: {
          online: "Online",
          offline: "Offline",
        },
        monitor: {
          no_check: "noch kein Check",
          target_https: "HTTPS-Monitor f√ºr {target}",
          delete_title: "L√∂scht den Monitor inklusive aller Daten",
          delete_aria: "Monitor {name} l√∂schen",
          delete_failed: "Monitor konnte nicht gel√∂scht werden. Bitte sp√§ter erneut versuchen.",
          delete_confirm:
            "Monitor \"{name}\" wirklich l√∂schen?\n\nDabei werden alle Daten dieses Monitors dauerhaft entfernt:\n- Checks\n- Uptime-Historie\n- Vorf√§lle\n- Tagesstatistiken\n\nDieser Vorgang kann nicht r√ºckg√§ngig gemacht werden.",
        },
        groups: {
          endpoint_one: "Endpoint",
          endpoint_many: "Endpoints",
          offline_suffix: "{count} offline",
        },
        interval: {
          custom: "Benutzerdefiniert ({value})",
        },
        week: {
          mo_short: "Mo",
          wed_short: "Mi",
          fri_short: "Fr",
        },
        legend: {
          ok: "Keine Fehler",
          warn: "Kleine Fehler",
          down: "Ausfall",
        },
        errors: {
          no_response_label: "keine Antwort",
          no_response_single: "Fehlercode: keine Antwort",
          http_code: "HTTP-Code: {codes}",
          http_codes: "HTTP-Codes: {codes}",
          codes: "Fehlercodes: {codes}",
        },
        response: {
          title: "Antwortzeit.",
          last_hour: "Letzte Stunde",
          avg: "Durchschnitt",
          p50: "P50 (Median)",
          p95: "P95",
          min: "Minimum",
          max: "Maximum",
          help_button_aria: "Erkl\u00e4rung zu P-Werten und Chart",
          help_button_title: "Erkl\u00e4rung anzeigen",
          help_close: "Schlie\u00dfen",
          help_title: "So liest du den Chart",
          help_p50: "P50 (Median): 50% aller Checks sind schneller als dieser Wert.",
          help_p95: "P95: 95% aller Checks sind schneller. Das zeigt Lastspitzen besser als der Durchschnitt.",
          help_chart: "Linie = Antwortzeit pro Check. Farbbereiche: gr\u00fcn < 100 ms, gelb 100-250 ms, rot > 250 ms.",
          help_tooltip: "Mit der Maus \u00fcber die Linie fahren f\u00fcr Zeitstempel, Statuscode und Fehler je Messpunkt.",
          tooltip_response: "Antwort",
          tooltip_status: "Status",
          tooltip_error: "Fehler",
        },
        slo: {
          title: "SLO & Error-Budget.",
          subtitle: "SLO-Ziel, Budgetverbrauch und Burn-Rate.",
          state_active: "Aktiv",
          state_inactive: "Nicht aktiviert",
          target_label: "SLO-Ziel",
          window_uptime: "Uptime (SLO-Fenster)",
          budget_remaining: "Verbleibendes Budget",
          budget_consumed: "Verbrauchtes Budget",
          burn_1h: "Burn-Rate 1h",
          burn_6h: "Burn-Rate 6h",
          burn_24h: "Burn-Rate 24h",
          window_meta: "Fenster {days} Tage: {incidents} Vorfaelle, {checks} Checks",
          budget_remaining_time: "{time} verbleibend",
          budget_consumed_time: "{time} verbraucht",
          card_enabled_note: "SLO-Auswertung basiert auf den letzten {days} Tagen.",
          card_disabled_note: "SLO ist deaktiviert. Aktiviere es unter ‚ÄûMehr Einstellungen‚Äú.",
          disabled_hint: "SLO ist derzeit deaktiviert.",
          no_data_short: "--",
          burn_title: "Burn-Rate: {rate}x ({state})",
          state: {
            healthy: "gesund",
            warn: "erhoeht",
            high: "hoch",
            critical: "kritisch",
            unknown: "unbekannt",
          },
          settings_title: "SLO-Ziel.",
          settings_desc: "Definiere dein Uptime-Ziel pro Monitor. Error-Budget und Burn-Rate richten sich danach.",
          explain_title: "Was sind SLO-Ziele?",
          explain_body:
            "Ein SLO-Ziel ist dein Verfuegbarkeitsversprechen, z.B. 99,9% in 30 Tagen. Daraus ergibt sich dein Error-Budget.",
          explain_example: "Beispiel: Bei 99,9% stehen dir in 30 Tagen etwa 43 Minuten Ausfallzeit als Budget zur Verfuegung.",
          settings_activation_hint_off: "Aktiviere SLO zuerst, damit Error-Budget und Burn-Rate berechnet werden.",
          settings_activation_hint_on: "Du kannst SLO jederzeit wieder deaktivieren.",
          activate_button: "SLO aktivieren",
          deactivate_button: "SLO deaktivieren",
          settings_target_label: "SLO-Ziel (%)",
          msg_activating: "SLO wird aktiviert ...",
          msg_deactivating: "SLO wird deaktiviert ...",
          msg_activated: "SLO aktiviert.",
          msg_deactivated: "SLO deaktiviert.",
          msg_saving: "Speichern ...",
          msg_saved: "Gespeichert.",
          msg_failed: "Speichern fehlgeschlagen.",
          msg_invalid: "Bitte einen gueltigen SLO-Wert eingeben.",
          msg_enable_first: "Bitte zuerst SLO aktivieren.",
        },
        domain_ssl: {
          title: "Domain & SSL.",
          domain_valid_until: "Domain g√ºltig bis",
          ssl_valid_until: "SSL-Zertifikat g√ºltig bis",
          source_rdap: "Quelle: RDAP",
          ip_target: "IP-Monitor (keine Domain)",
          public_unavailable: "√ñffentlich nicht verf√ºgbar",
          registry_no_expiry: "Die Registry ver√∂ffentlicht kein Ablaufdatum",
          no_https_target: "Kein HTTPS-Ziel",
          issuer: "Issuer: {issuer}",
        },
        regions: {
          title: "Regionen.",
          map_alt: "Weltkarte",
          location_loading: "Standort wird geladen‚Ä¶",
          unavailable: "Standort nicht verf√ºgbar",
          scope: {
            edge: "Edge-Standort{provider}",
            origin: "Serverstandort",
            generic: "Standort",
          },
          geodata_unavailable: "{scope}: Geodaten nicht verf√ºgbar",
          ip_location: "IP-Standort",
          asn_org: "ASN/Org",
        },
        incidents: {
          title: "Letzte Vorf√§lle.",
          empty_title: "üëç Gute Arbeit, keine Vorf√§lle.",
          empty_body: "Bisher gab es keine Vorf√§lle. Weiter so!",
          outage: "Ausfall",
          daily: "T√§glicher Vorfall",
          aggregated: "aggregiert",
          failed_checks: "Fehlchecks: {n}",
          checks: "Checks: {n}",
          ongoing: "l√§uft noch",
          open: "offen",
          unknown_day: "Tag unbekannt",
          footnote: "Zeigt die letzten 2 Vorf√§lle (Fenster: {days} Tage).",
          badge: {
            ongoing: "laufend",
            ended: "beendet",
          },
        },
        advanced: {
          title: "Mehr Einstellungen",
          meta: "SLO ¬∑ HTTP-Assertions ¬∑ Wartungen",
          unsaved_confirm: "Es gibt ungespeicherte √Ñnderungen. Wirklich schlie√üen?",
          card: {
            slo_title: "SLO-Ziel.",
            slo_desc: "Uptime-Ziel, Error-Budget und Burn-Rate getrennt und fokussiert bearbeiten.",
            open_slo: "SLO √∂ffnen",
            assertions_title: "HTTP-Assertions.",
            assertions_desc: "Statuscodes, Redirects und Inhaltspr√ºfungen separat konfigurieren.",
            open_assertions: "Assertions √∂ffnen",
            maintenance_title: "Wartungen.",
            maintenance_desc: "Wartungen planen und verwalten, ohne die anderen Einstellungen zu √ºberladen.",
            open_maintenance: "Wartungen √∂ffnen",
          },
          modal: {
            slo_title: "SLO-Einstellungen",
            assertions_title: "HTTP-Assertions",
            maintenance_title: "Wartungen",
            saved_badge: "Gespeichert",
          },
        },
        assertions: {
          title: "HTTP-Assertions.",
          desc: "Optional: pr√ºfe Statuscode, Redirects, Content-Type oder W√∂rter im Body.",
          enable: "Aktivieren",
          expected_codes: "Erwartete Statuscodes",
          follow_redirects: "Redirects folgen",
          max_redirects: "Max Redirects",
          content_type_contains: "Content-Type enth√§lt",
          body_contains: "Body enth√§lt",
          timeout_ms: "Timeout (ms)",
          placeholder: {
            codes: "z.B. 200-299,304",
            content_type: "z.B. text/html",
            body: "z.B. Willkommen",
          },
          msg_saving: "Speichern ...",
          msg_saved: "Gespeichert.",
          msg_failed: "Speichern fehlgeschlagen.",
        },
        maintenance: {
          title: "Wartungen.",
          desc: "Plane Wartungen, um Kunden auf der Statusseite vorab zu warnen. Erfordert eine verifizierte Domain.",
          badge: {
            scheduled: "geplant",
            active: "aktiv",
            completed: "abgeschlossen",
            cancelled: "abgebrochen",
          },
          label: {
            title: "Titel",
            start: "Start",
            end: "Ende",
            note_optional: "Hinweis (optional)",
          },
          placeholder: {
            title: "z.B. Datenbank-Update",
            note: "Kurze Info f√ºr Kunden...",
          },
          button: {
            schedule: "Wartung planen",
            verify_domain: "Domain verifizieren",
          },
          default_title: "Wartung",
          meta: {
            starts: " (startet in {remaining})",
            ends: " (endet in {remaining})",
          },
          disabled_title: "Wartungen sind noch nicht aktiv.",
          disabled_body: "Dein Server liefert noch keine Wartungsdaten (Backend-Update/Neustart fehlt).",
          empty_title: "Keine Wartungen.",
          empty_body: "Sobald du eine Wartung planst, erscheint sie hier.",
          msg_set_start_end: "Bitte Start und Ende setzen.",
          msg_end_after_start: "Ende muss nach dem Start liegen.",
          msg_scheduling: "Wartung wird geplant ...",
          msg_domain_not_verified: "Domain{host} ist nicht verifiziert. Bitte verifizieren, um Wartungen planen zu k√∂nnen.",
          msg_request_blocked:
            "Request wurde blockiert (Origin/Referer). Bitte die Seite direkt √ºber pingmyserver.de aufrufen und Proxy/CSP pr√ºfen.",
          msg_invalid_target:
            "Monitor-Ziel ist ung√ºltig (z.B. IP/localhost) und kann nicht per Domain-Verifizierung freigeschaltet werden.",
          msg_starts_past:
            "Startzeit liegt in der Vergangenheit. Bitte eine zuk√ºnftige Zeit w√§hlen (oder bei laufender Wartung: Ende in die Zukunft setzen).",
          msg_starts_too_far: "Startzeit liegt zu weit in der Zukunft. Bitte einen n√§heren Zeitpunkt w√§hlen.",
          msg_duration_too_short: "Wartung ist zu kurz. Mindestdauer sind 5 Minuten.",
          msg_duration_too_long: "Wartung ist zu lang. Maximal sind 30 Tage erlaubt.",
          msg_invalid_input: "Bitte Eingaben pr√ºfen: Ende muss nach dem Start liegen.",
          msg_invalid_start: "Start ist ung√ºltig. Bitte Datum/Uhrzeit neu setzen.",
          msg_invalid_end: "Ende ist ung√ºltig. Bitte Datum/Uhrzeit neu setzen.",
          msg_endpoint_not_found:
            "Endpoint nicht gefunden (HTTP 404). Das Feature ist auf dem Server vermutlich noch nicht deployed oder der Node-Prozess l√§uft noch mit altem Code.",
          msg_failed_http: "Wartung konnte nicht geplant werden. (HTTP {status})",
          msg_failed_detail: "Wartung konnte nicht geplant werden. ({detail})",
          msg_failed_network: "Wartung konnte nicht geplant werden.{detail}",
          msg_scheduled: "Wartung geplant.",
          msg_cancelling: "Wartung wird abgebrochen ...",
          msg_cancel_failed: "Wartung konnte nicht abgebrochen werden.",
          msg_cancelled: "Wartung abgebrochen.",
        },
      },
      monitors: {
        title: "Monitore",
        sub: "Domains, Projekte und Endpunkte verwalten",
        list_title: "Deine Monitore",
        empty: "Keine Monitore gefunden.",
        email_meta_on: "E-Mail: an",
        email_meta_off: "E-Mail: aus",
        email_toggle_on: "E-Mail an",
        email_toggle_off: "E-Mail aus",
        email_toggle_enable: "E-Mail-Benachrichtigung f√ºr diesen Monitor aktivieren",
        email_toggle_disable: "E-Mail-Benachrichtigung f√ºr diesen Monitor deaktivieren",
        email_toggle_enable_aria: "E-Mail-Benachrichtigung f√ºr {name} aktivieren",
        email_toggle_disable_aria: "E-Mail-Benachrichtigung f√ºr {name} deaktivieren",
        msg_email_saving: "E-Mail-Einstellung wird gespeichert...",
        msg_email_enabled: "E-Mail-Benachrichtigung f√ºr Monitor aktiviert.",
        msg_email_disabled: "E-Mail-Benachrichtigung f√ºr Monitor deaktiviert.",
        msg_email_save_failed: "E-Mail-Einstellung konnte nicht gespeichert werden.",
      },
      incidents: {
        title: "Vorfall-Log",
        sub: "Alle Vorf√§lle mit Details und Sortierung",
        empty_title: "Keine Vorf√§lle gefunden.",
        empty_body: "Passe Filter oder Zeitraum an.",
        no_data_body: "Vorf√§lle konnten nicht geladen werden.",
        summary: "Zeitraum: {days} Tage | Angezeigt: {shown} | Gesamt: {total} | Ausgeblendet: {hidden}",
        all_monitors: "Alle Monitore",
        actions: {
          hide: "Fehler ausblenden",
          hiding: "Fehler wird ausgeblendet...",
          hide_success: "Fehler wurde ausgeblendet.",
          hide_failed: "Fehler konnte nicht ausgeblendet werden.",
          hide_reason_prompt: "Bitte eine Begruendung eingeben, warum dieser Fehler ausgeblendet werden soll:",
          hide_reason_required: "Eine Begruendung ist erforderlich.",
        },
        history: {
          title: "Ausgeblendete Fehler (History)",
          sub: "Ausgeblendete Vorfaelle bleiben hier mit Begruendung sichtbar.",
          loading: "Lade ausgeblendete Fehler...",
          empty_title: "Keine ausgeblendeten Fehler.",
          empty_body: "Sobald Fehler ausgeblendet werden, erscheinen sie hier.",
          no_data_body: "History konnte nicht geladen werden.",
          hidden_at: "Ausgeblendet am",
          reason: "Begruendung",
          badge_hidden: "ausgeblendet",
        },
        badge: {
          aggregated: "aggregiert",
          raw: "roh",
        },
        detail: {
          range: "Zeitraum",
          duration: "Dauer",
          failed_checks: "Fehlchecks",
          monitor_id: "Monitor ID",
          status_codes: "Statuscodes",
          error_codes: "Fehlercodes",
          last_error: "Letzter Fehler",
        },
        controls: {
          title: "Filter & Sortierung",
          sort_by: "Sortieren nach",
          order: "Reihenfolge",
          range: "Zeitraum",
          max_entries: "Max. Eintr√§ge",
        },
        sort: {
          start: "Startzeit",
          duration: "Dauer",
          checks: "Fehlchecks",
        },
        lookback: {
          30: "30 Tage",
          90: "90 Tage",
          365: "365 Tage",
          730: "730 Tage",
        },
        loading: "Lade Vorf√§lle‚Ä¶",
        list: {
          title: "Alle Vorf√§lle",
        },
      },
      notifications: {
        title: "Benachrichtigungen",
        sub: "Benachrichtigungskan√§le f√ºr Statuswechsel deiner Monitore",
        email: {
          title: "E-Mail Benachrichtigung",
          copy: "Bei Statuswechseln (online/offline) senden wir eine E-Mail. Der Anti-Spam Cooldown verhindert Mail-Flut bei Flapping.",
          state_unavailable: "Nicht verf√ºgbar",
          state_disconnected: "Nicht verbunden",
          state_active: "Aktiv",
          state_configured_disabled: "Konfiguriert (deaktiviert)",
          smtp_missing: "SMTP ist nicht konfiguriert.",
          no_recipient: "Kein Empf√§nger hinterlegt.",
          recipient_configured: "Empf√§nger konfiguriert.",
          using_account_email: "Es wird deine Konto-E-Mail verwendet.",
          label_address: "Empf√§nger E-Mail (optional)",
          label_cooldown: "Cooldown pro Monitor (Minuten)",
          label_language: "E-Mail Sprache",
          lang_de: "Deutsch",
          lang_en: "Englisch",
          placeholder_address: "alerts@example.com",
          enable: "Benachrichtigungen aktivieren",
          test: "Test senden",
          remove: "E-Mail deaktivieren",
          confirm_remove: "E-Mail Benachrichtigungen deaktivieren?",
          cooldown_hint: "Anti-Spam Cooldown aktiv.",
          cooldown_hint_value: "Anti-Spam Cooldown: {minutes} Min pro Monitor",
          msg: {
            loading: "Lade Benachrichtigungen...",
            load_failed: "Einstellungen konnten nicht geladen werden.",
            smtp_missing: "SMTP ist nicht konfiguriert.",
            invalid_recipient: "Bitte eine g√ºltige Empf√§nger E-Mail eingeben.",
            invalid_language: "Bitte eine g√ºltige E-Mail Sprache ausw√§hlen.",
            saving: "Einstellungen werden gespeichert...",
            saved: "E-Mail Benachrichtigungen gespeichert.",
            save_failed: "Einstellungen konnten nicht gespeichert werden.",
            testing: "Test-E-Mail wird gesendet...",
            test_sent: "Test-E-Mail gesendet.",
            test_failed: "Test-E-Mail konnte nicht gesendet werden.",
            removing: "E-Mail Benachrichtigungen werden deaktiviert...",
            removed: "E-Mail Benachrichtigungen deaktiviert.",
            remove_failed: "E-Mail Einstellungen konnten nicht entfernt werden.",
          },
        },
        discord: {
          title: "Discord Webhook",
          copy: "Bei Statuswechseln (online/offline) senden wir eine Nachricht an deinen Discord Webhook.",
          state_disconnected: "Nicht verbunden",
          state_active: "Aktiv",
          state_configured_disabled: "Konfiguriert (deaktiviert)",
          no_webhook: "Kein Webhook hinterlegt.",
          webhook_configured: "Webhook konfiguriert.",
          label_url: "Webhook URL",
          placeholder_url: "https://discord.com/api/webhooks/...",
          enable: "Benachrichtigungen aktivieren",
          test: "Test senden",
          remove: "Webhook entfernen",
          confirm_remove: "Discord Webhook entfernen?",
          msg: {
            loading: "Lade Benachrichtigungen...",
            load_failed: "Einstellungen konnten nicht geladen werden.",
            webhook_required: "Bitte eine g√ºltige Discord Webhook URL eingeben.",
            webhook_required_first: "Bitte zuerst einen Webhook hinzuf√ºgen.",
            saving: "Einstellungen werden gespeichert...",
            saved: "Discord Benachrichtigungen gespeichert.",
            save_failed: "Einstellungen konnten nicht gespeichert werden.",
            invalid_webhook: "Ung√ºltige Discord Webhook URL.",
            testing: "Testnachricht wird gesendet...",
            test_sent: "Testnachricht gesendet.",
            test_failed: "Test konnte nicht gesendet werden.",
            removing: "Webhook wird entfernt...",
            removed: "Webhook entfernt.",
            remove_failed: "Webhook konnte nicht entfernt werden.",
          },
        },
        slack: {
          title: "Slack Incoming Webhook",
          copy: "Bei Statuswechseln (online/offline) senden wir eine Nachricht an deinen Slack Incoming Webhook.",
          state_disconnected: "Nicht verbunden",
          state_active: "Aktiv",
          state_configured_disabled: "Konfiguriert (deaktiviert)",
          no_webhook: "Kein Webhook hinterlegt.",
          webhook_configured: "Webhook konfiguriert.",
          label_url: "Webhook URL",
          placeholder_url: "https://hooks.slack.com/services/...",
          enable: "Benachrichtigungen aktivieren",
          test: "Test senden",
          remove: "Webhook entfernen",
          confirm_remove: "Slack Webhook entfernen?",
          msg: {
            loading: "Lade Benachrichtigungen...",
            load_failed: "Einstellungen konnten nicht geladen werden.",
            webhook_required: "Bitte eine g√ºltige Slack Webhook URL eingeben.",
            webhook_required_first: "Bitte zuerst einen Webhook hinzuf√ºgen.",
            saving: "Einstellungen werden gespeichert...",
            saved: "Slack Benachrichtigungen gespeichert.",
            save_failed: "Einstellungen konnten nicht gespeichert werden.",
            invalid_webhook: "Ung√ºltige Slack Webhook URL.",
            testing: "Testnachricht wird gesendet...",
            test_sent: "Testnachricht gesendet.",
            test_failed: "Test konnte nicht gesendet werden.",
            removing: "Webhook wird entfernt...",
            removed: "Webhook entfernt.",
            remove_failed: "Webhook konnte nicht entfernt werden.",
          },
        },
        webhook: {
          title: "HTTPS Webhook",
          copy: "Bei Statuswechseln (online/offline) senden wir eine JSON-Nachricht an deine HTTPS Webhook-URL. Optional signieren wir Requests mit einem Secret.",
          state_disconnected: "Nicht verbunden",
          state_active: "Aktiv",
          state_configured_disabled: "Konfiguriert (deaktiviert)",
          no_url: "Keine URL hinterlegt.",
          url_configured: "Webhook URL konfiguriert.",
          secret_configured: "Secret gesetzt (signiert).",
          secret_missing: "Kein Secret gesetzt.",
          label_url: "Webhook URL (https)",
          label_secret: "Secret (optional)",
          placeholder_url: "https://example.com/pingmyserver-webhook",
          placeholder_secret: "optional",
          enable: "Benachrichtigungen aktivieren",
          test: "Test senden",
          remove: "Webhook entfernen",
          confirm_remove: "Webhook entfernen?",
          msg: {
            loading: "Lade Benachrichtigungen...",
            load_failed: "Einstellungen konnten nicht geladen werden.",
            url_required: "Bitte eine g√ºltige HTTPS Webhook URL eingeben.",
            url_required_first: "Bitte zuerst eine Webhook URL hinzuf√ºgen.",
            saving: "Einstellungen werden gespeichert...",
            saved: "Webhook Benachrichtigungen gespeichert.",
            save_failed: "Einstellungen konnten nicht gespeichert werden.",
            invalid_url: "Ung√ºltige Webhook URL.",
            target_forbidden: "Diese Webhook URL ist nicht erlaubt (lokale/private Ziele sind blockiert).",
            testing: "Testnachricht wird gesendet...",
            test_sent: "Testnachricht gesendet.",
            test_failed: "Test konnte nicht gesendet werden.",
            removing: "Webhook wird entfernt...",
            removed: "Webhook entfernt.",
            remove_failed: "Webhook konnte nicht entfernt werden.",
          },
        },
        billing: {
          title: "Abrechnung (Stripe)",
          copy: "Upgrade auf einen bezahlten Plan und verwalte dein Abo im Stripe Customer Portal.",
          state_inactive: "Nicht aktiv",
          no_subscription: "Kein aktives Abo.",
          upgrade: "Mit Stripe upgraden",
          manage: "Abo verwalten",
          badge: {
            unavailable: "Nicht verf√ºgbar",
            active: "Aktiv",
            action_needed: "Aktion n√∂tig",
            free: "Kostenlos",
          },
          text: {
            unavailable: "Stripe Billing ist aktuell nicht aktiviert.",
            active: "Abo-Status: {status}.{suffix}",
            renewal: " N√§chste Verl√§ngerung: {date}.",
            action_needed: "Eine Zahlung ist √ºberf√§llig. Bitte im Portal aktualisieren.",
            free: "Du nutzt aktuell den kostenlosen Plan.",
          },
          msg: {
            loading: "Lade Billing...",
            load_failed: "Billing konnte nicht geladen werden.",
            checkout_preparing: "Stripe Checkout wird vorbereitet...",
            already_subscribed: "Abo ist bereits aktiv. Bitte im Portal verwalten.",
            stripe_disabled: "Stripe ist aktuell deaktiviert.",
            checkout_failed: "Checkout konnte nicht gestartet werden.",
            portal_opening: "Stripe Portal wird ge√∂ffnet...",
            portal_failed: "Portal konnte nicht ge√∂ffnet werden.",
            checkout_success: "Checkout abgeschlossen. Abo wird aktualisiert.",
            checkout_cancelled: "Checkout wurde abgebrochen.",
          },
        },
      },
      connections: {
        title: "Connections & Sicherheit",
        sub: "Aktive Sitzungen verwalten, Domains verifizieren und Passwort √§ndern",
        revoke_others: "Alle anderen trennen",
        app_connections: {
          title: "App Connections",
          loading: "Lade App Connections...",
          empty_title: "Keine App Connections.",
          empty_body: "Sobald Provider aktiviert sind, erscheinen sie hier.",
          summary: {
            zero: "0 App Connections",
            connected: "{connected}/{total} verbunden",
          },
          status: {
            connected: "verbunden",
            disconnected: "nicht verbunden",
          },
          subtitle: {
            connected_as: "Verbunden als @{account}",
            connected: "Verbunden",
            not_connected: "Noch nicht verbunden",
            coming_soon: "Kommt bald",
          },
          meta: {
            google_enabled: "Google Login (Gmail) kann √ºber die Login-Seite verkn√ºpft werden.",
            google_disabled: "Google Login (Gmail) ist aktuell deaktiviert.",
            discord_enabled: "Discord Login kann √ºber die Login-Seite verkn√ºpft werden.",
            discord_disabled: "Discord Login ist aktuell deaktiviert.",
            generic: "Provider-Status wird √ºber dein Konto verwaltet.",
          },
        },
        domains: {
          title: "Domain-Verifizierung",
          loading: "Lade Domains...",
          label: "Domain",
          create_challenge: "DNS-Challenge erstellen",
          empty_title: "Keine Domains.",
          empty_body: "Sobald du eine Domain hinzuf√ºgst, erscheint sie hier.",
          summary: {
            zero: "0 Domains",
            verified: "{verified}/{total} verifiziert",
          },
          badge: {
            verified: "Verifiziert",
            pending: "Ausstehend",
          },
          button: {
            verify: "Verifizieren",
            verified: "Verifiziert",
            reset_token: "Token neu generieren",
            remove: "Entfernen",
          },
          confirm_remove: "Domain-Verifizierung entfernen?",
          msg: {
            creating_challenge: "DNS-Challenge wird erstellt ...",
            conflict: "Diese Domain ist bereits in einem anderen Konto verifiziert.",
            create_failed_input: "Challenge konnte nicht erstellt werden. Bitte Eingabe pr√ºfen.",
            already_verified: "Domain ist bereits verifiziert.",
            challenge_created: "Challenge erstellt. TXT-Record setzen und anschlie√üend verifizieren.",
            create_failed: "Challenge konnte nicht erstellt werden.",
            verifying_dns: "DNS wird gepr√ºft ...",
            verified: "Domain verifiziert.",
            dns_not_ready: "DNS ist noch nicht bereit. Bitte sp√§ter erneut versuchen.",
            dns_lookup_failed: "DNS-Lookup fehlgeschlagen. Bitte sp√§ter erneut versuchen.",
            not_found: "Domain nicht gefunden.",
            verify_failed: "Verifizierung fehlgeschlagen.",
            removing: "Domain wird entfernt ...",
            removed: "Domain entfernt.",
            remove_failed: "Domain konnte nicht entfernt werden.",
            enter_domain: "Bitte eine Domain eingeben.",
          },
          record: {
            name_host: "Name/Host",
            txt_value: "TXT-Wert",
            token_loading: "(Token wird geladen...)",
            hint_html:
              "Je nach DNS-Provider kann der Host auch nur {host} sein.",
          },
          subtitle: {
            verified_at: "Verifiziert am {date}.",
            last_check: "Letzter Check: {date} ({relative})",
            set_txt: "TXT-Record setzen und anschlie√üend verifizieren.",
          },
        },
        team: {
          title: "Team",
          loading: "Lade Team...",
          summary: "Owner {owner} | {members} Mitglieder | {invitations} offene Einladungen",
          invite: {
            label: "E-Mail Einladung",
            placeholder: "mitglied@example.com",
            button: "Einladung senden",
          },
          verify: {
            title: "Teameinladung bestaetigen",
            copy: "Gib den Code aus der E-Mail ein und bestaetige die Einladung.",
            code_label: "Verifizierungscode",
            code_placeholder: "123456",
            button: "Einladung bestaetigen",
          },
          members: {
            title: "Mitglieder",
            empty_title: "Keine Teammitglieder.",
            empty_body: "Lade Mitglieder per E-Mail in dein Team ein.",
            badge: {
              owner: "Owner",
              member: "Mitglied",
            },
            joined: "Beigetreten {relative}",
            remove: "Entfernen",
            owner_fixed: "Owner",
            confirm_remove: "Mitglied aus dem Team entfernen?",
          },
          invites: {
            title: "Offene Einladungen",
            empty_title: "Keine offenen Einladungen.",
            empty_body: "Offene Einladungen erscheinen hier.",
            badge: {
              pending: "Ausstehend",
              expired: "Abgelaufen",
            },
            expires_in: "Laeuft ab in {expiresIn}",
            expired: "Abgelaufen",
            revoke: "Widerrufen",
            confirm_revoke: "Diese Einladung widerrufen?",
          },
          msg: {
            invite_sending: "Einladung wird gesendet...",
            already_member: "Diese Person ist bereits in deinem Team.",
            self_invite: "Du kannst deine eigene E-Mail nicht einladen.",
            verification_unavailable: "E-Mail-Verifizierung ist aktuell nicht verfuegbar.",
            invalid_email: "Bitte gib eine gueltige E-Mail ein.",
            invite_failed: "Einladung konnte nicht gesendet werden.",
            invite_sent: "Einladung an {email} gesendet.",
            invalid_invite_token: "Ungueltiger Einladungstoken.",
            invalid_invite_code: "Bitte einen gueltigen Verifizierungscode eingeben.",
            verifying: "Einladung wird verifiziert...",
            email_mismatch: "Bitte mit der eingeladenen E-Mail anmelden und erneut bestaetigen.",
            invalid_code_with_remaining: "Code ist ungueltig. Verbleibende Versuche: {remaining}.",
            invitation_expired: "Einladung ist abgelaufen.",
            invitation_attempts_exceeded: "Zu viele falsche Codes. Bitte neue Einladung anfordern.",
            invalid_invitation: "Einladung wurde nicht gefunden.",
            verify_failed: "Einladung konnte nicht verifiziert werden.",
            verify_success: "Einladung bestaetigt. Du bist jetzt im Team.",
            revoke_pending: "Einladung wird widerrufen...",
            revoke_failed: "Einladung konnte nicht widerrufen werden.",
            revoke_success: "Einladung widerrufen.",
            member_removing: "Teammitglied wird entfernt...",
            member_remove_failed: "Teammitglied konnte nicht entfernt werden.",
            member_removed: "Teammitglied entfernt.",
            enter_email: "Bitte eine E-Mail eingeben.",
          },
        },
        sessions: {
          title: "Aktive Sitzungen",
          loading: "Lade aktive Sitzungen...",
          empty_title: "Keine aktiven Sitzungen.",
          empty_body: "Sobald du dich anmeldest, erscheinen Sitzungen hier.",
          summary: {
            zero: "0 aktive Sitzungen",
            one_other: "{total} aktive Sitzungen, {others} weitere",
            many_other: "{total} aktive Sitzungen, {others} weitere",
          },
          expires_now: "l√§uft ab",
          row: {
            title: "Sitzung {id}",
            subtitle: {
              current: "Diese Sitzung",
              other: "Andere Sitzung",
            },
            badge: {
              current: "Aktuell",
              active: "Aktiv",
            },
            created: "Erstellt",
            expires: "L√§uft ab",
            action: {
              current: "Diese Sitzung",
              disconnect: "Trennen",
            },
          },
          msg: {
            disconnecting: "Sitzung wird getrennt ...",
            disconnected: "Sitzung getrennt.",
            disconnect_failed: "Sitzung konnte nicht getrennt werden.",
            revoking_others: "Andere Sitzungen werden getrennt ...",
            revoked_one: "{n} Sitzung getrennt. Aktuelle Sitzung bleibt aktiv.",
            revoked_many: "{n} Sitzungen getrennt. Aktuelle Sitzung bleibt aktiv.",
            revoke_failed: "Andere Sitzungen konnten nicht getrennt werden.",
          },
        },
        password: {
          title: "Passwort √§ndern",
          hint_required: "Aktuelles Passwort ist erforderlich.",
          hint_optional: "Optional (bei Login via App-Provider).",
          current: "Aktuelles Passwort",
          placeholder_optional: "Optional bei App-Login",
          new: "Neues Passwort",
          repeat: "Neues Passwort wiederholen",
          save: "Passwort speichern",
          msg: {
            enter_current: "Bitte aktuelles Passwort eingeben.",
            invalid_length: "Neues Passwort muss {min}-{max} Zeichen lang sein.",
            mismatch: "Neue Passw√∂rter stimmen nicht √ºberein.",
            must_differ: "Neues Passwort muss anders sein.",
            saving: "Passwort wird gespeichert ...",
            current_wrong: "Aktuelles Passwort ist falsch.",
            reauth_required: "Bitte erneut anmelden und die Aktion wiederholen.",
            same_password: "Neues Passwort darf nicht identisch sein.",
            current_required: "Aktuelles Passwort ist erforderlich.",
            invalid_input: "Bitte Eingaben pr√ºfen.",
            change_failed: "Passwort konnte nicht ge√§ndert werden.",
            saved: "Passwort gespeichert.",
            set: "Passwort gesetzt.",
            revoked_one: "{n} andere Sitzung getrennt.",
            revoked_many: "{n} andere Sitzungen getrennt.",
          },
        },
        delete: {
          title: "Konto l√∂schen",
          desc: "Dadurch werden dein Konto, alle Monitore und alle aktiven Sitzungen dauerhaft gel√∂scht.",
          confirm: "Konto dauerhaft l√∂schen",
          hint_optional: "Optional (bei Login via App-Provider).",
          msg: {
            enter_current: "Bitte aktuelles Passwort eingeben.",
            deleting: "Konto wird gel√∂scht ...",
            current_wrong: "Aktuelles Passwort ist falsch.",
            delete_failed: "Konto konnte nicht gel√∂scht werden.",
            deleted: "Konto gel√∂scht. Weiterleitung ...",
          },
        },
      },
      owner: {
        crumb: "Owner",
        title: "Owner Ops Dashboard",
        sub: "Serverlast, Monitorkosten und Schwachpunkte in Echtzeit",
        badge: "Owner",
        badge_id: "Owner #{id}",
        cards: {
          server_load: {
            title: "Serverlast",
            sub: "Laufzeitmetriken seit Prozessstart",
          },
          check_engine: {
            title: "Check-Engine",
            sub: "Scheduler, Durchsatz und parallele Checks",
          },
          database: {
            title: "Datenbank",
            sub: "Pool-Auslastung und Query-Verhalten",
          },
          costs: {
            title: "Teuerste Monitore (24h)",
            sub: "Sortiert nach Cost-Score (Checks, Antwortzeit, Fehler, Timeouts)",
          },
          security: {
            title: "Security-Insights",
            sub: "Blockierungen, Auth-Risiken und h√§ufige Fehlerbilder",
          },
          db_storage: {
            title: "DB-Speicherverlauf",
            sub: "Wachstum der Datenbank und freier Speicherplatz auf dem Server.",
          },
        },
        table: {
          user: "User",
          status: "Status",
          checks_24h: "Checks 24h",
          error_rate: "Fehlerquote",
          avg_ms: "√ò ms",
          timeouts: "Timeouts",
          score: "Score",
          no_monitor_data: "Keine Monitor-Daten verf√ºgbar.",
        },
        stats: {
          cpu_avg: "CPU √ò",
          cpu_p95: "CPU p95",
          event_loop_p95: "Event Loop p95",
          rss: "RSS",
          heap_used: "Heap genutzt",
          uptime: "Uptime",
          monitors_active: "Monitore (aktiv)",
          checks_10m: "Checks 10 Min.",
          failure_rate_10m: "Fehlerrate 10 Min.",
          check_p95_duration: "Check p95 Dauer",
          in_flight: "In Flight",
          scheduler_drift_p95: "Scheduler Drift p95",
          queries_total: "Queries gesamt",
          slow_queries: "Slow Queries",
          db_query_p95: "DB Query p95",
          db_ops_active: "DB Ops aktiv",
          acquire_wait_p95: "Acquire Wait p95",
          pool_busy: "Pool busy",
          pool_free: "Pool free",
          pool_queue: "Pool queue",
          pool_max_busy: "Pool max busy",
          db_storage_used: "DB belegt",
          db_storage_growth: "Wachstum",
          db_storage_server_free: "Server frei",
          db_storage_sampled_at: "Letzte Messung",
        },
        value: {
          seconds: "{value} Sek.",
          in_flight: "{current} (max {max})",
        },
        status: {
          paused: "pausiert",
        },
        security: {
          runtime: "Runtime Security Counter",
          top_errors: "Top Fehlermeldungen (24h)",
          failing_monitors: "Auff√§llige Monitore (24h)",
          auth: "Auth-Lage",
          invalid_origin_blocked: "Invalid-Origin blockiert: {value}",
          rate_limited_blocked: "Rate-Limit geblockt: {value}",
          oauth_state_rejected: "OAuth-State abgewiesen: {value}",
          target_blocked: "Target-Blockierungen: {value}",
          block_reason: "Blockgrund {key}: {value}",
          failing_monitor_line: "{name} ¬∑ User {user} ¬∑ {rate} ({failed}/{total})",
          auth_lockouts: "Aktive Lockouts: {value}",
          auth_failures_24h: "Auth-Fehler (24h): {value}",
          auth_tracked_failures: "Verfolgte Failure-Records: {value}",
        },
        db_storage: {
          no_data: "Noch keine DB-Speicherdaten verf√ºgbar.",
          waiting: "Warte auf erste Messpunkte...",
          footnote: "Zeitraum: {hours}h ¬∑ Punkte: {points} ¬∑ Wachstum: {growth}",
        },
        email_test: {
          title: "E-Mail-Test (Owner)",
          sub: "Sende eine Test-E-Mail √ºber den konfigurierten SMTP-Account.",
          from: "Von",
          to: "An (Empf√§nger)",
          template: "E-Mail-Typ",
          template_verification: "Verifikations-Mail testen",
          template_alert_started: "Alert eingeleitet Mail testen",
          template_alert_resolved: "Alert aufgehoben Mail testen",
          template_label_verification: "Verifikations-Mail",
          template_label_alert_started: "Alert eingeleitet",
          template_label_alert_resolved: "Alert aufgehoben",
          subject: "Betreff (optional)",
          send: "Test-E-Mail senden",
          send_loading: "Sende...",
          placeholder_to: "deine-mail@example.com",
          placeholder_subject: "Dein PingMyServer Verifizierungscode",
          smtp_missing: "SMTP ist nicht konfiguriert.",
          from_missing: "Nicht konfiguriert",
          config: "SMTP: {host}:{port} ¬∑ {security} ¬∑ {auth}",
          config_security_secure: "SMTPS",
          config_security_starttls: "STARTTLS",
          config_security_plain: "Unverschl√ºsselt",
          config_auth_none: "ohne Login",
          config_auth_user: "Login {user}",
          msg: {
            enter_recipient: "Bitte eine g√ºltige Empf√§nger-E-Mail eingeben.",
            invalid_template: "Bitte einen g√ºltigen E-Mail-Typ ausw√§hlen.",
            sending: "Test-E-Mail wird gesendet...",
            sent: "Test-E-Mail ({template}) gesendet an {to} ({time}).",
            not_configured: "SMTP ist nicht vollst√§ndig konfiguriert.",
            invalid_recipient: "Empf√§nger-Adresse ist ung√ºltig.",
            failed: "E-Mail konnte nicht versendet werden.",
          },
        },
      },
      status: {
        h1: "PingMyServer Statusseite",
        brand: {
          title: "Statusseite",
        },
        unavailable: {
          target: "Kein Monitor ausgew√§hlt",
          label: "Kein Monitor verf√ºgbar",
          state: "Nicht verf√ºgbar",
          hint: "Bitte √∂ffne die Statusseite aus deinem Dashboard.",
        },
        checking: "Pr√ºfe Status‚Ä¶",
        state: {
          maintenance_running: "Wartung l√§uft",
          operational: "Alle Systeme betriebsbereit",
          outage_detected: "Ausfall erkannt",
        },
        duration: {
          online_for: "Online seit {duration}",
          offline_for: "Offline seit {duration}",
          maintenance_until: "Wartung bis {until} (endet in {remaining})",
        },
        waiting_first_check: "Warte auf ersten Check",
        check_interval: "Pr√ºfintervall: {interval}",
        maintenance: {
          title: "Wartung",
          planned: "Geplant",
          active: "Aktiv",
          meta: {
            ends: "{start} ‚Äì {end} ¬∑ endet in {remaining}",
            starts: "{start} ‚Äì {end} ¬∑ startet in {remaining}",
          },
        },
        hero: {
          current_status: "Aktueller Status",
          last_check: "Letzter Check",
          last_24h: "Letzte 24 Stunden",
        },
        range: {
          last_7_days: "Letzte 7 Tage",
          last_30_days: "Letzte 30 Tage",
          last_365_days: "Letzte 365 Tage",
          choose: "Zeitraum w√§hlen",
          default: "Letzte 30 Tage",
          last_days: "Letzte {days} Tage",
          more_soon: "Weitere Auswertungen folgen",
        },
        incidents: {
          title: "Letzte Vorf√§lle",
          empty_title: "Diese Statusseite hat bisher keine Vorf√§lle verzeichnet.",
          empty_body: "Sobald ein Vorfall erkannt wird, erscheint er hier.",
          footnote: "Zeigt Vorf√§lle der letzten {days} Tage.",
        },
        updated_at: "Zuletzt aktualisiert: ‚Äì",
        updated_at_with_time: "Zuletzt aktualisiert: {time}",
      },
      game_monitor: {
        title: "Game Monitor",
        sub: "Game Server live tracken: Ping, Spieler und mehr",
        games: {
          title: "Spiele",
          minecraft_name: "Minecraft",
          minecraft_note: "Java Edition",
        },
        minecraft: {
          title: "Minecraft Server",
          sub: "Trage Server ein und verfolge Status, Ping, Spielerzahlen und Version.",
        },
        form: {
          name_label: "Servername (optional)",
          name_placeholder: "Mein Survival Server",
          host_label: "Host oder IP",
          host_placeholder: "play.example.net:25565",
          add: "Server hinzuf√ºgen",
        },
        hint_tps: "TPS ist oft nur verf√ºgbar, wenn der Server es aktiv bereitstellt (z. B. per Plugin/RCON).",
        mod: {
          title: "Game Agent Verbindung",
          create_pairing: "Verifizierungscode erzeugen",
          sub: "Erstelle einen Pairing-Code im Web und nutze ihn in deinem Agent/Mod. Solange Heartbeats gesendet werden, bleibt die Verbindung online.",
          code_label: "Aktueller Code",
          expires_label: "G√ºltig bis",
          sessions_title: "Verbundene Mod Sessions",
          sessions_empty_title: "Keine Mod Session verbunden.",
          sessions_empty_body: "Erzeuge einen Pairing-Code und verbinde deinen {game} Agent/Mod.",
          status_online: "Online",
          status_offline: "Offline",
          status_disconnected: "Getrennt",
          status_revoked: "Widerrufen",
          revoke: "Session trennen",
          instance_label: "Instanz",
          heartbeat_label: "Letzter Heartbeat",
          mod_version_label: "Mod Version",
        },
        empty: {
          title: "Noch keine Server hinterlegt.",
          body: "F√ºge deinen ersten Minecraft Server hinzu.",
        },
        state: {
          loading: "Wird aktualisiert",
          online: "Online",
          offline: "Offline",
        },
        metrics: {
          ping: "Ping",
          tps: "TPS",
          tps_na: "n/a",
          players: "Spieler",
          version: "Version",
          motd_empty: "Keine MOTD verf√ºgbar.",
          updated: "Aktualisiert",
          sample: "Beispielspieler",
        },
        dashboard: {
          crumb: "Game Monitoring",
          header_subtitle: "Live Uebersicht fuer deine Minecraft Mod Verbindung",
          updated_fallback: "Letztes Update: --",
          updated_at: "Letztes Update: {time}",
          create_pairing: "Verifizierungscode erzeugen",
          server_name_fallback: "Minecraft Mod Monitor",
          status: {
            online: "Online",
            degraded: "Degraded",
            offline: "Offline",
            not_connected: "Nicht verbunden",
          },
          connection: {
            title: "Minecraft Mod Connection",
            sub: "Nutze den Pairing-Code in deiner Mod. Sobald Heartbeats ankommen, erscheinen die Live-Metriken automatisch.",
            code_label: "Aktueller Code",
            expires_label: "Gueltig bis",
            no_code: "Kein aktiver Code",
          },
          kpis: {
            title: "Server KPIs",
            current_tps: "Current TPS",
            online_players: "Online Players",
            average_ping: "Average Ping",
            cpu_usage: "CPU Usage",
            memory_usage: "Memory Usage",
            uptime: "Uptime (24h)",
          },
          health: {
            title: "Overall Health",
            description: "Berechnet aus TPS, Session-Status und Latenz ({online}/{total} online)",
          },
          trend: {
            waiting: "Warte auf Daten",
            vs_recent: "vs letzte Samples",
            live_value: "Live aus Mod-Metriken",
          },
          charts: {
            tps_title: "TPS ueber Zeit",
            players_title: "Spieler ueber Zeit",
          },
          chart_stats: {
            minimum: "Minimum",
            maximum: "Maximum",
            current: "Aktuell",
            peak: "Peak",
            average: "Durchschnitt",
          },
          live_metrics: {
            title: "Live Server Metrics",
            rows: {
              tps: "TPS",
              tps_extra: "Direkt aus Mod-Metriken",
              ping: "Average Ping",
              ping_extra: "Mittelwert ueber aktive Sessions",
              players: "Players",
              players_extra: "Online / Max",
              sessions: "Sessions",
              sessions_extra: "Online / Gesamt",
              version: "Server Version",
              version_extra: "Version aus Mod-Heartbeat",
              world: "World",
              world_extra: "Falls von der Mod geliefert",
              dimension: "Dimension",
              dimension_extra: "Falls von der Mod geliefert",
              motd: "MOTD",
              motd_extra: "Aktueller MOTD-Text",
              mod_version: "Mod Version",
              mod_version_extra: "Gemeldet von der verbundenen Session",
              instance: "Instance",
              instance_extra: "Eindeutige Session-ID",
              heartbeat: "Last Heartbeat",
              heartbeat_extra: "Zeitpunkt des letzten Heartbeats",
              cpu: "CPU Usage",
              cpu_extra: "Mittelwert ueber aktive Sessions",
              memory: "Memory Usage",
              memory_extra: "Aggregiert ueber aktive Sessions",
              packet_loss: "Packet Loss",
              packet_loss_extra: "Durchschnitt in Prozent",
            },
          },
          events: {
            title: "Events / Incidents",
            new_session: "Neue Session erkannt: {session}",
            session_recovered: "Session wieder online: {session}",
            session_stale: "Heartbeat stale/offline: {session}",
            session_removed: "Session getrennt oder entfernt: {session}",
            no_changes: "Noch keine Session-Statusaenderungen erkannt.",
            type_restart: "RESTART",
            type_error: "ERROR",
            type_disconnect: "DISCONNECT",
            type_connect: "CONNECT",
            type_warning: "WARNING",
            type_info: "INFO",
          },
          sessions: {
            title: "Mod Sessions",
            empty_body: "Erzeuge einen Pairing-Code und verbinde deinen Minecraft Server mit der Mod.",
            world: "World",
          },
          plugins: {
            title: "Mods & Plugins",
            empty: "Noch keine Plugin-Daten aus der Mod erhalten.",
            summary_count: "{count} Plugins erkannt",
            enabled: "Aktiv",
            disabled: "Deaktiviert",
            version_unknown: "Version unbekannt",
          },
          latency: {
            title: "Latency by Region",
            empty: "Noch keine regionalen Latenzwerte verfuegbar.",
            summary_count: "{count} Regionen",
          },
          discord: {
            title: "Discord Integration",
            channel: "#server-status",
            status_label: "Status",
            test_button: "Send test alert",
            settings_link: "Zu den Einstellungen",
            status_loading: "Wird geladen",
            status_loading_desc: "Discord-Konfiguration wird geladen.",
            status_not_configured: "Nicht konfiguriert",
            not_configured_desc: "Lege in den Verbindungen einen Discord-Webhook fest.",
            status_enabled: "Aktiv",
            enabled_desc: "Alerts aktiv ({webhook})",
            status_disabled: "Deaktiviert",
            disabled_desc: "Webhook hinterlegt, aber Alerts sind deaktiviert ({webhook})",
            test_sent: "Discord-Test versendet.",
            test_failed: "Discord-Test konnte nicht gesendet werden.",
          },
          insight: {
            title: "AI Insight",
            no_data_1: "Noch keine Mod Session verbunden. Erzeuge einen Pairing-Code und verbinde deinen Server.",
            no_data_2: "Sobald Heartbeats eingehen, erscheinen hier Hinweise zu TPS, Ping und Session-Stabilitaet.",
            stable_tps: "TPS liegt stabil nahe 20. Die Tick-Performance sieht gesund aus.",
            low_tps: "TPS liegt bei {tps}. Beobachte Lastspitzen.",
            waiting_tps: "Die Mod sendet aktuell noch keine TPS-Werte.",
            high_ping: "Ping ist mit {ping} ms erhoeht. Netzwerkpfad und Host-Last pruefen.",
            partial_online: "{online} von {total} Sessions sind online.",
            healthy: "Alle verbundenen Sessions senden regelmaessig Heartbeats.",
          },
        },
        messages: {
          invalid_address: "Bitte gib einen g√ºltigen Host ein.",
          duplicate: "Server ist bereits in der Liste.",
          limit: "Maximal {count} Server m√∂glich.",
          added: "Server hinzugef√ºgt.",
          removed: "Server entfernt.",
          refreshed: "Live-Daten aktualisiert.",
          pairing_created: "Pairing-Code erstellt.",
          pairing_failed: "Code konnte nicht erstellt werden.",
          session_revoked: "Session getrennt.",
          session_revoke_failed: "Session konnte nicht getrennt werden.",
          remove_game_confirm: "Spiel \"{game}\" wirklich entfernen?",
          remove_game_success: "Spiel \"{game}\" entfernt.",
          remove_game_failed: "Spiel konnte nicht entfernt werden.",
          remove_game_blocked: "Dieses Spiel kann nicht entfernt werden.",
          direct_probe_unavailable: "Direkte Server-Abfrage ist aktuell nur f√ºr Minecraft verf√ºgbar. Nutze f√ºr {game} die Agent-Verbindung.",
        },
        error_codes: {
          dns_not_found: "DNS konnte nicht aufgel√∂st werden.",
          connection_refused: "Verbindung vom Server abgelehnt.",
          timeout: "Server antwortet nicht (Timeout).",
          unreachable: "Server ist nicht erreichbar.",
          invalid_status: "Ung√ºltige Statusantwort erhalten.",
          connection_closed: "Verbindung wurde fr√ºhzeitig geschlossen.",
          request_failed: "Statusabfrage fehlgeschlagen.",
          connection_failed: "Verbindung fehlgeschlagen.",
          probe_failed: "Server konnte nicht gepr√ºft werden.",
          target_blocked: "Ziel ist aus Sicherheitsgr√ºnden blockiert.",
          invalid_input: "Eingabe ist ung√ºltig.",
          unauthorized: "Session abgelaufen. Bitte neu anmelden.",
        },
      },
      common: {
        language: "Sprache",
        lang_de: "Deutsch",
        lang_en: "Englisch",
        aria: {
          home: "PingMyServer Startseite",
          profile_settings: "Connections und Kontoeinstellungen",
        },
        account: "Konto",
        legal: "Rechtliches",
        terms: "Nutzungsbedingungen",
        privacy: "Datenschutz",
        imprint: "Impressum",
        back_home: "Zur Startseite",
        status_page: "Statusseite",
        monitoring: "Monitoring",
        monitors: "Monitore",
        monitor: "Monitor",
        location: "Standort",
        aggregate: "Gesamt",
        interval: "Intervall",
        new_monitor: "Neuer Monitor",
        public_status_page: "√ñffentliche Statusseite",
        save: "Speichern",
        refresh: "Aktualisieren",
        asc: "Aufsteigend",
        desc: "Absteigend",
        incidents: "Vorf√§lle",
        notifications: "Benachrichtigungen",
        game_monitor: "Game Monitor",
        connections: "Connections",
        owner_ops: "Owner Ops",
        your_monitors: "Deine Monitore",
        signed_in: "eingeloggt",
        logout: "Abmelden",
        loading: "wird geladen‚Ä¶",
        loading_data: "Lade Daten...",
        please_wait: "Bitte kurz warten.",
        error_loading: "Fehler beim Laden.",
        try_again: "Bitte erneut versuchen.",
        try_again_later: "Bitte sp√§ter erneut versuchen.",
        no_data: "Keine Daten",
        no_data_available: "Keine Daten verf√ºgbar.",
        not_available: "k.A.",
        unknown: "unbekannt",
        none: "keine",
        delete: "L√∂schen",
        cancel: "Abbrechen",
        connection_failed: "Verbindung fehlgeschlagen.",
      },
    },
    en: {
      meta: {
        login: {
          title: "Sign in - PingMyServer",
          description: "Sign in to PingMyServer to manage monitoring, incidents and notifications.",
        },
        onboarding: {
          title: "Onboarding ¬∑ PingMyServer",
          description: "Onboarding in PingMyServer: create your first monitor and start monitoring.",
        },
        landing: {
          title: "PingMyServer - Uptime Monitoring for Websites, APIs and Services",
          description:
            "PingMyServer monitors websites, APIs and services 24/7. Get outage alerts via Discord, email and webhook in seconds.",
          og_title: "PingMyServer - Uptime Monitoring for Websites, APIs and Services",
          og_description: "Uptime monitoring for websites, APIs and services with fast alerts and a public status page.",
          twitter_title: "PingMyServer - Uptime Monitoring",
          twitter_description: "Monitor websites and APIs 24/7 and receive alerts in seconds.",
        },
        app: {
          title: "Dashboard ¬∑ PingMyServer",
          description: "PingMyServer dashboard for monitoring, uptime history and alerts.",
        },
        monitors: {
          title: "Monitors ¬∑ PingMyServer",
          description: "Manage monitors: domains, projects and API endpoints.",
        },
        incidents: {
          title: "Incidents ¬∑ PingMyServer",
          description: "Incident overview in PingMyServer with history and outage details.",
        },
        notifications: {
          title: "Notifications ¬∑ PingMyServer",
          description: "Configure and manage notification channels in PingMyServer.",
        },
        connections: {
          title: "Connections ¬∑ PingMyServer",
          description: "Manage connections and integrations in PingMyServer.",
        },
        game_monitor: {
          title: "Game Monitor - PingMyServer",
          description: "Game monitor for Minecraft servers: status, ping, player counts and more live metrics.",
        },
        privacy: {
          title: "Privacy policy ¬∑ PingMyServer",
          description: "PingMyServer privacy policy: information about processing, storage and your rights under GDPR.",
          og_title: "Privacy policy ¬∑ PingMyServer",
          og_description: "PingMyServer privacy policy.",
          twitter_title: "Privacy policy ¬∑ PingMyServer",
          twitter_description: "PingMyServer privacy policy.",
        },
        imprint: {
          title: "Imprint ¬∑ PingMyServer",
          description: "PingMyServer imprint with provider information and contact details.",
          og_title: "Imprint ¬∑ PingMyServer",
          og_description: "PingMyServer imprint.",
          twitter_title: "Imprint ¬∑ PingMyServer",
          twitter_description: "PingMyServer imprint.",
        },
        terms: {
          title: "Terms ¬∑ PingMyServer",
          description: "PingMyServer terms with rules on usage, service scope, cancellation and liability.",
          og_title: "Terms ¬∑ PingMyServer",
          og_description: "PingMyServer terms.",
          twitter_title: "Terms ¬∑ PingMyServer",
          twitter_description: "PingMyServer terms.",
        },
        owner: {
          title: "Owner Ops ¬∑ PingMyServer",
          description: "PingMyServer owner overview for operational metrics and top monitors.",
        },
        status: {
          title: "Status page ¬∑ PingMyServer",
          description: "PingMyServer live status page with uptime, incidents and recent checks in real time.",
          og_title: "PingMyServer Status page",
          og_description: "Live status page with uptime, incidents and recent checks.",
          twitter_title: "PingMyServer Status page",
          twitter_description: "Live status page with uptime and incidents.",
        },
      },
      onboarding: {
        h1: "Which site do you want to monitor?",
        p1: "Enter a domain or URL. Examples:",
        p2: "or",
        label: {
          url: "URL or domain",
          name: "Name (optional)",
        },
        placeholder: {
          name: "My shop",
        },
        endpoints: {
          summary: "API endpoints (optional)",
          hint1: "One path per line. Example:",
          hint2: "or",
          hint3: "Tip: use",
          hint4: "for the root URL.",
          label: "Endpoints (one per line)",
          placeholder: "/API/Ping.php\n/API/get.php",
        },
        button: {
          create: "Create monitor",
        },
        msg: {
          enter_url: "Please enter a domain or URL.",
          creating: "Creating monitor...",
          creating_many: "Creating {count} monitors...",
          creating_many_progress: "{done}/{total} created...",
          created_redirect: "Monitor created. Redirecting...",
          created_many_redirect: "{count} monitors created. Redirecting...",
        },
        error: {
          local_target_forbidden: "Local targets like localhost are not allowed for security reasons.",
          private_target_forbidden: "Private IP targets are not allowed. Please add the host to the private allowlist.",
          mixed_target_forbidden:
            "The domain resolves to both public and private DNS targets. Please set MONITOR_PRIVATE_TARGET_POLICY=all_private.",
          invalid_protocol: "Only http:// or https:// are allowed.",
          invalid_url: "The URL is invalid. Please check your input.",
          target_blocked: "The target was blocked by the security policy.",
          invalid_input: "Please check the URL/domain.",
          monitor_limit_reached: "Monitor limit reached. Please delete old monitors or increase your limit.",
          internal_error: "Internal error while creating the monitor. Please try again later.",
          backend_503: "Backend is currently unavailable (HTTP 503). Please restart the server service.",
          proxy_502: "Proxy error to backend (HTTP 502). Please check the server service and Apache proxy.",
          bad_request_400: "The web server rejected the request as invalid (HTTP 400).",
          forbidden_403: "The web server blocked the request (HTTP 403).",
          unauthorized_401: "Session is no longer valid. Please sign in again.",
          webserver_rejected: "The request was rejected by the web server.",
          create_failed: "Monitor could not be created.",
          endpoints_too_many: "Too many endpoints. Max is {max}.",
          endpoint_invalid: "Invalid endpoint: {value}",
          endpoint_failed: "{created}/{total} created. Failed on {value}: {detail}",
        },
      },
      login: {
        h1: "Sign in or create an account",
        sub: "GitHub, Google and Discord login are available once OAuth is enabled.",
        divider: "or with email",
        aria: {
          auth: "Authentication",
        },
        mode: {
          login: "Sign in",
          register: "Create account",
        },
        label: {
          email: "Email",
          password: "Password",
          verification_code: "Verification code",
        },
        placeholder: {
          verification_code: "123456",
        },
        button: {
          sign_in: "Sign in",
          create_account: "Create account",
          verify_code: "Verify code",
          resend_code: "Resend code",
          resend_code_wait: "Resend code ({seconds}s)",
          back_to_login: "Back to sign in",
        },
        verify: {
          hint_default: "We sent a verification code to your email.",
          hint_sent: "We sent a code to {email}. Valid for {seconds} seconds.",
        },
        msg: {
          invalid_email_password: "Please enter a valid email and a password with {min}-{max} characters.",
          signing_in: "Signing in...",
          too_many_attempts: "Too many attempts. Please try again later.",
          too_many_attempts_retry: "Too many attempts. Try again in {seconds} seconds.",
          invalid_credentials: "Invalid email or password.",
          login_failed: "Sign in failed.",
          login_success: "Signed in. Redirecting...",
          registering: "Creating account...",
          register_failed: "Registration failed.",
          register_success: "Account created. Redirecting...",
          verification_code_sent: "Verification code sent. Please check your inbox.",
          verification_code_resent: "Verification code sent again.",
          verification_unavailable: "Verification is currently unavailable. Please try again in a few minutes.",
          verification_send_failed: "Verification email could not be sent. Please try again.",
          verification_throttled: "Too many verification requests. Please try again later.",
          verifying_code: "Verifying code...",
          invalid_verification_code: "Please enter the {length}-digit verification code.",
          invalid_verification_code_with_remaining: "Invalid code. Remaining attempts: {remaining}.",
          verification_expired: "Verification expired. Please sign in again to request a new code.",
          verification_attempts_exceeded: "Too many invalid codes. Please sign in again to request a new code.",
          verification_failed: "Verification failed.",
          resending_code: "Resending verification code...",
          resend_cooldown: "Please wait {seconds} seconds before requesting a new code.",
          resend_limit_reached: "Resend limit reached. Please sign in again.",
          oauth_coming_soon: "{provider} sign-in will be available once OAuth is enabled.",
        },
        oauth: {
          default: "OAuth sign-in failed.",
          discord_disabled: "Discord login is currently disabled.",
          discord_denied: "Discord sign-in was cancelled.",
          discord_state: "Discord sign-in has expired. Please try again.",
          discord_code: "Discord sign-in failed (no code received).",
          discord_token: "Discord token could not be retrieved.",
          discord_scope: "Discord did not grant email scope. Please authorize again.",
          discord_profile: "Discord profile could not be read.",
          discord_email_missing: "No verified email found on Discord.",
          discord_conflict: "This email is already linked to another Discord account.",
          discord_error: "Discord sign-in failed. Please try again.",
          github_disabled: "GitHub login is currently disabled.",
          github_denied: "GitHub sign-in was cancelled.",
          github_state: "GitHub sign-in has expired. Please try again.",
          github_code: "GitHub sign-in failed (no code received).",
          github_token: "GitHub token could not be retrieved.",
          github_scope:
            "GitHub did not grant email scope. Please remove the app permission and sign in again.",
          github_email_permission:
            "The GitHub app needs permission 'Email addresses: Read-only'. Please enable it and authorize again.",
          github_profile: "GitHub profile could not be read.",
          github_email_missing: "No verified email found on GitHub.",
          github_conflict: "This email is already linked to another GitHub account.",
          github_error: "GitHub sign-in failed. Please try again.",
          google_disabled: "Google login is currently disabled.",
          google_denied: "Google sign-in was cancelled.",
          google_state: "Google sign-in has expired. Please try again.",
          google_code: "Google sign-in failed (no code received).",
          google_token: "Google token could not be retrieved.",
          google_scope: "Google did not grant email scope. Please authorize again.",
          google_profile: "Google profile could not be read.",
          google_email_missing: "No verified email found on Google.",
          google_conflict: "This email is already linked to another Google account.",
          google_error: "Google sign-in failed. Please try again.",
        },
      },
      landing: {
        nav: {
          features: "Features",
          pricing: "Pricing",
          faq: "FAQ",
          status: "Status page",
          login: "Sign in",
          dashboard: "Dashboard",
          cta: "Start free",
        },
        hero: {
          badge: "Now in early access",
          h1: {
            line1: "Detect outages early,",
            highlight: "before users",
            line2: "report them",
          },
          lead:
            "PingMyServer monitors your websites, APIs and services around the clock. Get instant notifications during outages via Discord, webhook or email.",
          benefit: {
            setup: "Setup in under 60 seconds",
            no_cc: "No credit card required",
            public_status: "Public status page included",
          },
          cta_primary: "Start early access ->",
          cta_secondary: "View live demo",
          note: "Completely free during early access ‚Ä¢ Made in Germany",
        },
        live: {
          title: "Live Status",
          overall_loading: "Loading monitor data ...",
          monitor_loading: "Loading monitor ...",
          checking: "Checking ...",
          response_placeholder: "Response: --",
          response_value: "Response: {ms}ms",
          uptime_placeholder: "--% Uptime",
          uptime_value: "{uptime}% Uptime",
          no_monitor: "No monitor available",
          overall: {
            no_data: "No monitor data available",
            operational: "All systems operational",
            offline: {
              one: "{n} monitor offline",
              many: "{n} monitors offline",
            },
          },
          alert_title: "Recent Alert",
          alert_now: "just now",
          alert_none: "No incidents found yet.",
          alert: {
            none_full: "No recent incidents found.",
            offline: "{label} is currently offline{code}",
            outage: "{label} had an outage{code}",
          },
        },
        social: {
          h3: "Built by developers, for developers",
          sub: "An apprenticeship project with professional standards",
          stat: {
            monitoring: "Monitoring",
            interval: "Check interval",
            uptime: "Target uptime",
            made_in: "Made in Germany",
          },
        },
        features: {
          h2: "Everything you need for professional monitoring",
          lead:
            "From simple HTTP checks to complex API monitoring: PingMyServer gives you all the tools for reliable uptime monitoring.",
          cards: {
            fast_checks: {
              title: "Lightning-fast checks",
              body:
                "Monitor your endpoints every 60 seconds. Get alerts within seconds after an outage, before your customers notice.",
            },
            incident_history: {
              title: "Detailed incident history",
              body: "Complete log of all incidents with duration, error rate and timeline. Perfect for postmortems and reporting.",
            },
            alerts: {
              title: "Multi-channel alerts",
              body: "Discord, Slack, email, webhooks, Telegram: choose your preferred channel, or use all of them at once.",
            },
            ssl: {
              title: "SSL certificate monitoring",
              body: "Automatic SSL certificate monitoring. Get notified in time before a certificate expires.",
            },
            locations: {
              title: "Global monitoring locations",
              body: "Monitor your services from multiple locations worldwide and detect regional outages instantly.",
            },
            public_status: {
              title: "Public status page",
              body: "Branded status page for your customers. Show transparency with real-time status and incident updates.",
            },
          },
        },
        about: {
          h2: "Why we built PingMyServer",
          sub: "A student project with a real mission",
          founder_title: "Founder & Developer",
          story: {
            p1:
              "After high school, I'm now doing an apprenticeship and started building web projects on the side. The problem: my sites went down from time to time without me noticing. I only knew once users reported it, and that was embarrassing.",
            p2:
              "Existing monitoring tools were either too expensive for my apprentice budget or far too complex for my needs. So I built PingMyServer: a simple, reliable tool that does exactly what it should, without the fluff.",
            p3:
              "Now I want to share it with other apprentices, students and developers. Feedback and improvement suggestions are very welcome!",
          },
          values: {
            open: {
              title: "Open Development",
              body: "We build transparently and listen to our community's feedback",
            },
            heart: {
              title: "Made with heart",
              body: "Built with modern technology and attention to detail",
            },
            join: {
              title: "Join early",
              body: "Be there from the start and help shape the future of the tool",
            },
          },
          contact_prompt: "Got questions or feedback?",
          contact_cta: "Contact via email ->",
        },
        pricing: {
          h2: "Pricing",
          sub: "Beta is completely free. Starter and Pro / Team are coming soon.",
          per_month: "/month",
          coming_soon: "Coming soon",
          planned_button: "Planned",
          beta: {
            name: "Beta",
            tagline: "Completely free",
            per: "/during beta",
            features: {
              unlimited: "Unlimited monitors",
              checks_60: "60-second checks",
              alert_channels: "All alert channels",
              public_status: "Public status page",
              ssl: "SSL monitoring",
            },
            cta: "Get beta access",
            no_cc: "No credit card required",
          },
          starter: {
            name: "Starter",
            tagline: "Planned for later",
            features: {
              more_monitors: "More monitors",
              checks_30: "Faster checks (30s)",
              stats: "Advanced statistics",
              api: "API access",
              support: "Priority support",
            },
          },
          pro: {
            name: "Pro / Team",
            tagline: "For later",
            features: {
              unlimited: "Unlimited monitors",
              team: "Team collaboration",
              branding: "Custom branding",
              locations: "Dedicated locations",
              support: "Premium support",
            },
          },
          note: "Beta: free. Starter and Pro / Team: planned.",
        },
        faq: {
          h2: "FAQ",
          sub: "Everything you need to know about PingMyServer",
          items: {
            private: {
              q: "Can I monitor private websites too?",
              a: "Yes, but direct private or local IP targets are blocked for security reasons. You can use HTTP authentication or set custom headers.",
            },
            speed: {
              q: "How quickly is an outage detected?",
              a: "With 60-second checks (default) within about a minute. On paid plans you can reduce intervals down to 30 seconds so outages are detected even faster.",
            },
            share: {
              q: "How do I share status with customers?",
              a: "Each monitor has a public status page you can link to. It shows real-time status, uptime statistics and past incidents. You can also add your own branding (on paid plans).",
            },
            gdpr: {
              q: "Is PingMyServer GDPR compliant?",
              a: "Yes. All data is hosted in the EU (Frankfurt, Germany). We only collect required monitoring data and do not share it with third parties. You can export or delete your data at any time.",
            },
            cancel: {
              q: "What happens if I cancel?",
              a: "You can cancel anytime with one click. Your account stays active until the end of the paid period. Afterwards, monitors are disabled but your data is kept for 90 days in case you come back.",
            },
            api: {
              q: "Is there an API?",
              a: "Yes. Starting with the Starter plan, you get access to our REST API. Create monitors programmatically, check status and fetch incidents, perfect for CI/CD integration.",
            },
          },
        },
        cta: {
          h2: "Ready to join the community?",
          p1: "Get your free beta access now and help us",
          p2: "build the best uptime monitoring tool for developers.",
          primary: "Get beta access ->",
          secondary: "View status page",
          note: "Completely free ‚Ä¢ No credit card ‚Ä¢ Made with heart in Germany",
        },
        footer: {
          pitch: "Professional uptime monitoring for websites, APIs and services.",
          product: "Product",
          api_docs: "API Docs",
          status: "Status",
          company: "Company",
          about: "About",
          commits: "Commits",
          contact: "Contact",
          legal: "Legal",
          terms_short: "Terms",
          gdpr: "GDPR",
          email: "Email",
        },
      },
      app: {
        dashboard: {
          current_status: "Current status",
          last_check: "Last check",
          check_interval_placeholder: "Check interval: 1 min.",
          check_interval: "Check interval: {interval}",
          waiting_first_check: "Waiting for first check",
          online_for: "Online for {duration}",
          offline_for: "Offline for {duration}",
          last_24h: "Last 24 hours",
          uptime_placeholder: "0 incidents, 0 min downtime",
          uptime_title: "Uptime: {uptime}%",
          summary: {
            one: "{incidents} incident, {minutes} min downtime",
            many: "{incidents} incidents, {minutes} min downtime",
          },
          last_7_days: "Last 7 days",
          last_30_days: "Last 30 days",
          last_365_days: "Last 365 days",
          choose_range: "Choose range",
          range_default: "Last 30 days",
          range_last_days: "Last {days} days",
          daily_overview: "Daily overview.",
        },
        state: {
          online: "Online",
          offline: "Offline",
        },
        monitor: {
          no_check: "no check yet",
          target_https: "HTTPS monitor for {target}",
          delete_title: "Deletes the monitor including all data",
          delete_aria: "Delete monitor {name}",
          delete_failed: "Monitor could not be deleted. Please try again later.",
          delete_confirm:
            "Delete monitor \"{name}\"?\n\nThis will permanently remove all data for this monitor:\n- Checks\n- Uptime history\n- Incidents\n- Daily statistics\n\nThis action cannot be undone.",
        },
        groups: {
          endpoint_one: "endpoint",
          endpoint_many: "endpoints",
          offline_suffix: "{count} offline",
        },
        interval: {
          custom: "Custom ({value})",
        },
        week: {
          mo_short: "Mon",
          wed_short: "Wed",
          fri_short: "Fri",
        },
        legend: {
          ok: "No errors",
          warn: "Minor issues",
          down: "Outage",
        },
        errors: {
          no_response_label: "no response",
          no_response_single: "Error code: no response",
          http_code: "HTTP code: {codes}",
          http_codes: "HTTP codes: {codes}",
          codes: "Error codes: {codes}",
        },
        response: {
          title: "Response time.",
          last_hour: "Last hour",
          avg: "Average",
          p50: "P50 (median)",
          p95: "P95",
          min: "Minimum",
          max: "Maximum",
          help_button_aria: "Explanation for percentile values and chart",
          help_button_title: "Show explanation",
          help_close: "Close",
          help_title: "How to read this chart",
          help_p50: "P50 (median): 50% of checks are faster than this value.",
          help_p95: "P95: 95% of checks are faster. This highlights spikes better than the average.",
          help_chart: "Line = response time per check. Color bands: green < 100 ms, yellow 100-250 ms, red > 250 ms.",
          help_tooltip: "Hover the line to see timestamp, status code, and error for each data point.",
          tooltip_response: "Response",
          tooltip_status: "Status",
          tooltip_error: "Error",
        },
        slo: {
          title: "SLO & Error Budget.",
          subtitle: "SLO target, budget consumption and burn rate.",
          state_active: "Active",
          state_inactive: "Not enabled",
          target_label: "SLO target",
          window_uptime: "Uptime (SLO window)",
          budget_remaining: "Remaining budget",
          budget_consumed: "Consumed budget",
          burn_1h: "Burn rate 1h",
          burn_6h: "Burn rate 6h",
          burn_24h: "Burn rate 24h",
          window_meta: "Window {days} days: {incidents} incidents, {checks} checks",
          budget_remaining_time: "{time} remaining",
          budget_consumed_time: "{time} consumed",
          card_enabled_note: "SLO analytics are based on the last {days} days.",
          card_disabled_note: "SLO is disabled. Enable it under \"More settings\".",
          disabled_hint: "SLO is currently disabled.",
          no_data_short: "--",
          burn_title: "Burn rate: {rate}x ({state})",
          state: {
            healthy: "healthy",
            warn: "elevated",
            high: "high",
            critical: "critical",
            unknown: "unknown",
          },
          settings_title: "SLO target.",
          settings_desc: "Define your uptime target per monitor. Error budget and burn rate are calculated from it.",
          explain_title: "What are SLO targets?",
          explain_body:
            "An SLO target is your availability promise, e.g. 99.9% over 30 days. It defines your error budget.",
          explain_example: "Example: At 99.9%, you have about 43 minutes of downtime budget in 30 days.",
          settings_activation_hint_off: "Enable SLO first so error budget and burn rate can be calculated.",
          settings_activation_hint_on: "You can disable SLO again at any time.",
          activate_button: "Enable SLO",
          deactivate_button: "Disable SLO",
          settings_target_label: "SLO target (%)",
          msg_activating: "Enabling SLO ...",
          msg_deactivating: "Disabling SLO ...",
          msg_activated: "SLO enabled.",
          msg_deactivated: "SLO disabled.",
          msg_saving: "Saving ...",
          msg_saved: "Saved.",
          msg_failed: "Save failed.",
          msg_invalid: "Please enter a valid SLO value.",
          msg_enable_first: "Please enable SLO first.",
        },
        domain_ssl: {
          title: "Domain & SSL.",
          domain_valid_until: "Domain valid until",
          ssl_valid_until: "SSL certificate valid until",
          source_rdap: "Source: RDAP",
          ip_target: "IP monitor (no domain)",
          public_unavailable: "Publicly unavailable",
          registry_no_expiry: "The registry does not publish an expiry date",
          no_https_target: "No HTTPS target",
          issuer: "Issuer: {issuer}",
        },
        regions: {
          title: "Regions.",
          map_alt: "World map",
          location_loading: "Loading location‚Ä¶",
          unavailable: "Location unavailable",
          scope: {
            edge: "Edge location{provider}",
            origin: "Server location",
            generic: "Location",
          },
          geodata_unavailable: "{scope}: Geodata unavailable",
          ip_location: "IP location",
          asn_org: "ASN/Org",
        },
        incidents: {
          title: "Recent incidents.",
          empty_title: "üëç Nice work, no incidents.",
          empty_body: "No incidents so far. Keep it up!",
          outage: "Outage",
          daily: "Daily incident",
          aggregated: "aggregated",
          failed_checks: "Failed checks: {n}",
          checks: "Checks: {n}",
          ongoing: "ongoing",
          open: "open",
          unknown_day: "Unknown day",
          footnote: "Shows the last 2 incidents (window: {days} days).",
          badge: {
            ongoing: "ongoing",
            ended: "ended",
          },
        },
        advanced: {
          title: "More settings",
          meta: "SLO ¬∑ HTTP assertions ¬∑ Maintenance",
          unsaved_confirm: "You have unsaved changes. Close anyway?",
          card: {
            slo_title: "SLO target.",
            slo_desc: "Edit uptime target, error budget and burn rate in one focused place.",
            open_slo: "Open SLO",
            assertions_title: "HTTP assertions.",
            assertions_desc: "Configure status codes, redirects and content checks separately.",
            open_assertions: "Open assertions",
            maintenance_title: "Maintenance.",
            maintenance_desc: "Plan and manage maintenance without overloading other settings.",
            open_maintenance: "Open maintenance",
          },
          modal: {
            slo_title: "SLO settings",
            assertions_title: "HTTP assertions",
            maintenance_title: "Maintenance",
            saved_badge: "Saved",
          },
        },
        assertions: {
          title: "HTTP assertions.",
          desc: "Optional: check status code, redirects, content type, or words in the body.",
          enable: "Enable",
          expected_codes: "Expected status codes",
          follow_redirects: "Follow redirects",
          max_redirects: "Max redirects",
          content_type_contains: "Content type contains",
          body_contains: "Body contains",
          timeout_ms: "Timeout (ms)",
          placeholder: {
            codes: "e.g. 200-299,304",
            content_type: "e.g. text/html",
            body: "e.g. Welcome",
          },
          msg_saving: "Saving ...",
          msg_saved: "Saved.",
          msg_failed: "Save failed.",
        },
        maintenance: {
          title: "Maintenance.",
          desc: "Schedule maintenance to warn customers on the status page. Requires a verified domain.",
          badge: {
            scheduled: "scheduled",
            active: "active",
            completed: "completed",
            cancelled: "cancelled",
          },
          label: {
            title: "Title",
            start: "Start",
            end: "End",
            note_optional: "Note (optional)",
          },
          placeholder: {
            title: "e.g. Database update",
            note: "Short note for customers...",
          },
          button: {
            schedule: "Schedule maintenance",
            verify_domain: "Verify domain",
          },
          default_title: "Maintenance",
          meta: {
            starts: " (starts in {remaining})",
            ends: " (ends in {remaining})",
          },
          disabled_title: "Maintenances are not active yet.",
          disabled_body: "Your server is not providing maintenance data yet (backend update/restart is missing).",
          empty_title: "No maintenance.",
          empty_body: "Once you schedule maintenance, it will show up here.",
          msg_set_start_end: "Please set start and end.",
          msg_end_after_start: "End must be after start.",
          msg_scheduling: "Scheduling maintenance ...",
          msg_domain_not_verified: "Domain{host} is not verified. Please verify it to schedule maintenances.",
          msg_request_blocked:
            "Request was blocked (Origin/Referer). Please open the site directly via pingmyserver.de and check proxy/CSP.",
          msg_invalid_target:
            "Monitor target is invalid (e.g. IP/localhost) and cannot be unlocked via domain verification.",
          msg_starts_past:
            "Start time is in the past. Please choose a future time (or for ongoing maintenance: set end in the future).",
          msg_starts_too_far: "Start time is too far in the future. Please choose a closer time.",
          msg_duration_too_short: "Maintenance is too short. Minimum duration is 5 minutes.",
          msg_duration_too_long: "Maintenance is too long. Maximum is 30 days.",
          msg_invalid_input: "Please check your input: end must be after start.",
          msg_invalid_start: "Start is invalid. Please set date/time again.",
          msg_invalid_end: "End is invalid. Please set date/time again.",
          msg_endpoint_not_found:
            "Endpoint not found (HTTP 404). The feature is probably not deployed yet or the node process is running old code.",
          msg_failed_http: "Maintenance could not be scheduled. (HTTP {status})",
          msg_failed_detail: "Maintenance could not be scheduled. ({detail})",
          msg_failed_network: "Maintenance could not be scheduled.{detail}",
          msg_scheduled: "Maintenance scheduled.",
          msg_cancelling: "Cancelling maintenance ...",
          msg_cancel_failed: "Maintenance could not be cancelled.",
          msg_cancelled: "Maintenance cancelled.",
        },
      },
      monitors: {
        title: "Monitors",
        sub: "Manage domains, projects and endpoints",
        list_title: "Your monitors",
        empty: "No monitors found.",
        email_meta_on: "Email: on",
        email_meta_off: "Email: off",
        email_toggle_on: "Email on",
        email_toggle_off: "Email off",
        email_toggle_enable: "Enable email notifications for this monitor",
        email_toggle_disable: "Disable email notifications for this monitor",
        email_toggle_enable_aria: "Enable email notifications for {name}",
        email_toggle_disable_aria: "Disable email notifications for {name}",
        msg_email_saving: "Saving email setting...",
        msg_email_enabled: "Email notifications enabled for monitor.",
        msg_email_disabled: "Email notifications disabled for monitor.",
        msg_email_save_failed: "Email setting could not be saved.",
      },
      incidents: {
        title: "Incident log",
        sub: "All incidents with details and sorting",
        empty_title: "No incidents found.",
        empty_body: "Adjust filters or the time range.",
        no_data_body: "Incidents could not be loaded.",
        summary: "Range: {days} days | Showing: {shown} | Total: {total} | Hidden: {hidden}",
        all_monitors: "All monitors",
        actions: {
          hide: "Hide incident",
          hiding: "Hiding incident...",
          hide_success: "Incident hidden.",
          hide_failed: "Incident could not be hidden.",
          hide_reason_prompt: "Please enter a reason for hiding this incident:",
          hide_reason_required: "A reason is required.",
        },
        history: {
          title: "Hidden incidents (history)",
          sub: "Hidden incidents remain visible here with their reason.",
          loading: "Loading hidden incidents...",
          empty_title: "No hidden incidents.",
          empty_body: "Hidden incidents will appear here.",
          no_data_body: "History could not be loaded.",
          hidden_at: "Hidden at",
          reason: "Reason",
          badge_hidden: "hidden",
        },
        badge: {
          aggregated: "aggregated",
          raw: "raw",
        },
        detail: {
          range: "Range",
          duration: "Duration",
          failed_checks: "Failed checks",
          monitor_id: "Monitor ID",
          status_codes: "Status codes",
          error_codes: "Error codes",
          last_error: "Last error",
        },
        controls: {
          title: "Filters & sorting",
          sort_by: "Sort by",
          order: "Order",
          range: "Range",
          max_entries: "Max entries",
        },
        sort: {
          start: "Start time",
          duration: "Duration",
          checks: "Failed checks",
        },
        lookback: {
          30: "30 days",
          90: "90 days",
          365: "365 days",
          730: "730 days",
        },
        loading: "Loading incidents‚Ä¶",
        list: {
          title: "All incidents",
        },
      },
      notifications: {
        title: "Notifications",
        sub: "Notification channels for monitor status changes",
        email: {
          title: "Email notifications",
          copy: "When a monitor changes status (online/offline), we send an email. The anti-spam cooldown prevents alert floods during flapping.",
          state_unavailable: "Unavailable",
          state_disconnected: "Not connected",
          state_active: "Active",
          state_configured_disabled: "Configured (disabled)",
          smtp_missing: "SMTP is not configured.",
          no_recipient: "No recipient configured.",
          recipient_configured: "Recipient configured.",
          using_account_email: "Using your account email address.",
          label_address: "Recipient email (optional)",
          label_cooldown: "Cooldown per monitor (minutes)",
          label_language: "Email language",
          lang_de: "German",
          lang_en: "English",
          placeholder_address: "alerts@example.com",
          enable: "Enable notifications",
          test: "Send test",
          remove: "Disable email",
          confirm_remove: "Disable email notifications?",
          cooldown_hint: "Anti-spam cooldown active.",
          cooldown_hint_value: "Anti-spam cooldown: {minutes} min per monitor",
          msg: {
            loading: "Loading notifications...",
            load_failed: "Settings could not be loaded.",
            smtp_missing: "SMTP is not configured.",
            invalid_recipient: "Please enter a valid recipient email.",
            invalid_language: "Please choose a valid email language.",
            saving: "Saving settings...",
            saved: "Email notifications saved.",
            save_failed: "Settings could not be saved.",
            testing: "Sending test email...",
            test_sent: "Test email sent.",
            test_failed: "Test email could not be sent.",
            removing: "Disabling email notifications...",
            removed: "Email notifications disabled.",
            remove_failed: "Email settings could not be removed.",
          },
        },
        discord: {
          title: "Discord webhook",
          copy: "When a monitor changes status (online/offline), we send a message to your Discord webhook.",
          state_disconnected: "Not connected",
          state_active: "Active",
          state_configured_disabled: "Configured (disabled)",
          no_webhook: "No webhook configured.",
          webhook_configured: "Webhook configured.",
          label_url: "Webhook URL",
          placeholder_url: "https://discord.com/api/webhooks/...",
          enable: "Enable notifications",
          test: "Send test",
          remove: "Remove webhook",
          confirm_remove: "Remove Discord webhook?",
          msg: {
            loading: "Loading notifications...",
            load_failed: "Settings could not be loaded.",
            webhook_required: "Please enter a valid Discord webhook URL.",
            webhook_required_first: "Please add a webhook first.",
            saving: "Saving settings...",
            saved: "Discord notifications saved.",
            save_failed: "Settings could not be saved.",
            invalid_webhook: "Invalid Discord webhook URL.",
            testing: "Sending test message...",
            test_sent: "Test message sent.",
            test_failed: "Test could not be sent.",
            removing: "Removing webhook...",
            removed: "Webhook removed.",
            remove_failed: "Webhook could not be removed.",
          },
        },
        slack: {
          title: "Slack incoming webhook",
          copy: "When a monitor changes status (online/offline), we send a message to your Slack incoming webhook.",
          state_disconnected: "Not connected",
          state_active: "Active",
          state_configured_disabled: "Configured (disabled)",
          no_webhook: "No webhook configured.",
          webhook_configured: "Webhook configured.",
          label_url: "Webhook URL",
          placeholder_url: "https://hooks.slack.com/services/...",
          enable: "Enable notifications",
          test: "Send test",
          remove: "Remove webhook",
          confirm_remove: "Remove Slack webhook?",
          msg: {
            loading: "Loading notifications...",
            load_failed: "Settings could not be loaded.",
            webhook_required: "Please enter a valid Slack webhook URL.",
            webhook_required_first: "Please add a webhook first.",
            saving: "Saving settings...",
            saved: "Slack notifications saved.",
            save_failed: "Settings could not be saved.",
            invalid_webhook: "Invalid Slack webhook URL.",
            testing: "Sending test message...",
            test_sent: "Test message sent.",
            test_failed: "Test could not be sent.",
            removing: "Removing webhook...",
            removed: "Webhook removed.",
            remove_failed: "Webhook could not be removed.",
          },
        },
        webhook: {
          title: "HTTPS webhook",
          copy: "When a monitor changes status (online/offline), we send a JSON payload to your HTTPS webhook URL. Optionally we sign requests with a secret.",
          state_disconnected: "Not connected",
          state_active: "Active",
          state_configured_disabled: "Configured (disabled)",
          no_url: "No webhook URL configured.",
          url_configured: "Webhook URL configured.",
          secret_configured: "Secret configured (signed).",
          secret_missing: "No secret configured.",
          label_url: "Webhook URL (https)",
          label_secret: "Secret (optional)",
          placeholder_url: "https://example.com/pingmyserver-webhook",
          placeholder_secret: "optional",
          enable: "Enable notifications",
          test: "Send test",
          remove: "Remove webhook",
          confirm_remove: "Remove webhook?",
          msg: {
            loading: "Loading notifications...",
            load_failed: "Settings could not be loaded.",
            url_required: "Please enter a valid HTTPS webhook URL.",
            url_required_first: "Please add a webhook URL first.",
            saving: "Saving settings...",
            saved: "Webhook notifications saved.",
            save_failed: "Settings could not be saved.",
            invalid_url: "Invalid webhook URL.",
            target_forbidden: "This webhook URL is not allowed (local/private targets are blocked).",
            testing: "Sending test message...",
            test_sent: "Test message sent.",
            test_failed: "Test could not be sent.",
            removing: "Removing webhook...",
            removed: "Webhook removed.",
            remove_failed: "Webhook could not be removed.",
          },
        },
        billing: {
          title: "Billing (Stripe)",
          copy: "Upgrade to a paid plan and manage your subscription in the Stripe Customer Portal.",
          state_inactive: "Inactive",
          no_subscription: "No active subscription.",
          upgrade: "Upgrade with Stripe",
          manage: "Manage subscription",
          badge: {
            unavailable: "Unavailable",
            active: "Active",
            action_needed: "Action needed",
            free: "Free",
          },
          text: {
            unavailable: "Stripe billing is currently not enabled.",
            active: "Subscription status: {status}.{suffix}",
            renewal: " Next renewal: {date}.",
            action_needed: "A payment is past due. Please update it in the portal.",
            free: "You are currently on the free plan.",
          },
          msg: {
            loading: "Loading billing...",
            load_failed: "Billing could not be loaded.",
            checkout_preparing: "Preparing Stripe Checkout...",
            already_subscribed: "Subscription is already active. Please manage it in the portal.",
            stripe_disabled: "Stripe is currently disabled.",
            checkout_failed: "Checkout could not be started.",
            portal_opening: "Opening Stripe portal...",
            portal_failed: "Portal could not be opened.",
            checkout_success: "Checkout completed. Subscription will be updated.",
            checkout_cancelled: "Checkout was cancelled.",
          },
        },
      },
      connections: {
        title: "Connections & Security",
        sub: "Manage active sessions, verify domains and change your password",
        revoke_others: "Disconnect others",
        app_connections: {
          title: "App connections",
          loading: "Loading app connections...",
          empty_title: "No app connections.",
          empty_body: "Once providers are enabled, they will show up here.",
          summary: {
            zero: "0 app connections",
            connected: "{connected}/{total} connected",
          },
          status: {
            connected: "connected",
            disconnected: "not connected",
          },
          subtitle: {
            connected_as: "Connected as @{account}",
            connected: "Connected",
            not_connected: "Not connected yet",
            coming_soon: "Coming soon",
          },
          meta: {
            google_enabled: "Google login (Gmail) can be linked via the login page.",
            google_disabled: "Google login (Gmail) is currently disabled.",
            discord_enabled: "Discord login can be linked via the login page.",
            discord_disabled: "Discord login is currently disabled.",
            generic: "Provider status is managed via your account.",
          },
        },
        domains: {
          title: "Domain verification",
          loading: "Loading domains...",
          label: "Domain",
          create_challenge: "Create DNS challenge",
          empty_title: "No domains.",
          empty_body: "Once you add a domain, it will show up here.",
          summary: {
            zero: "0 domains",
            verified: "{verified}/{total} verified",
          },
          badge: {
            verified: "Verified",
            pending: "Pending",
          },
          button: {
            verify: "Verify",
            verified: "Verified",
            reset_token: "Regenerate token",
            remove: "Remove",
          },
          confirm_remove: "Remove domain verification?",
          msg: {
            creating_challenge: "Creating DNS challenge...",
            conflict: "This domain is already verified in another account.",
            create_failed_input: "Challenge could not be created. Please check your input.",
            already_verified: "Domain is already verified.",
            challenge_created: "Challenge created. Set the TXT record and then verify.",
            create_failed: "Challenge could not be created.",
            verifying_dns: "Checking DNS...",
            verified: "Domain verified.",
            dns_not_ready: "DNS is not ready yet. Please try again later.",
            dns_lookup_failed: "DNS lookup failed. Please try again later.",
            not_found: "Domain not found.",
            verify_failed: "Verification failed.",
            removing: "Removing domain...",
            removed: "Domain removed.",
            remove_failed: "Domain could not be removed.",
            enter_domain: "Please enter a domain.",
          },
          record: {
            name_host: "Name/Host",
            txt_value: "TXT value",
            token_loading: "(token loading...)",
            hint_html: "Depending on your DNS provider, the host can be just {host}.",
          },
          subtitle: {
            verified_at: "Verified on {date}.",
            last_check: "Last check: {date} ({relative})",
            set_txt: "Set the TXT record and then verify.",
          },
        },
        team: {
          title: "Team",
          loading: "Loading team...",
          summary: "Owner {owner} | {members} members | {invitations} open invitations",
          invite: {
            label: "Invite email",
            placeholder: "member@example.com",
            button: "Send invitation",
          },
          verify: {
            title: "Confirm team invitation",
            copy: "Enter the code from your email and confirm the invitation.",
            code_label: "Verification code",
            code_placeholder: "123456",
            button: "Confirm invitation",
          },
          members: {
            title: "Members",
            empty_title: "No team members.",
            empty_body: "Invite members by email to collaborate.",
            badge: {
              owner: "Owner",
              member: "Member",
            },
            joined: "Joined {relative}",
            remove: "Remove",
            owner_fixed: "Owner",
            confirm_remove: "Remove this member from your team?",
          },
          invites: {
            title: "Open invitations",
            empty_title: "No open invitations.",
            empty_body: "Open invitations will show up here.",
            badge: {
              pending: "Pending",
              expired: "Expired",
            },
            expires_in: "Expires in {expiresIn}",
            expired: "Expired",
            revoke: "Revoke",
            confirm_revoke: "Revoke this invitation?",
          },
          msg: {
            invite_sending: "Sending invitation...",
            already_member: "This user is already in your team.",
            self_invite: "You cannot invite your own email.",
            verification_unavailable: "Email verification is currently unavailable.",
            invalid_email: "Please enter a valid email.",
            invite_failed: "Invitation could not be sent.",
            invite_sent: "Invitation sent to {email}.",
            invalid_invite_token: "Invalid invitation token.",
            invalid_invite_code: "Please enter a valid verification code.",
            verifying: "Verifying invitation...",
            email_mismatch: "Sign in with the invited email address before confirming.",
            invalid_code_with_remaining: "Verification code is invalid. Remaining attempts: {remaining}.",
            invitation_expired: "Invitation has expired.",
            invitation_attempts_exceeded: "Too many invalid codes. Request a new invitation.",
            invalid_invitation: "Invitation could not be found.",
            verify_failed: "Invitation could not be verified.",
            verify_success: "Invitation verified. You are now part of the team.",
            revoke_pending: "Revoking invitation...",
            revoke_failed: "Invitation could not be revoked.",
            revoke_success: "Invitation revoked.",
            member_removing: "Removing team member...",
            member_remove_failed: "Team member could not be removed.",
            member_removed: "Team member removed.",
            enter_email: "Please enter an email address.",
          },
        },
        sessions: {
          title: "Active sessions",
          loading: "Loading active sessions...",
          empty_title: "No active sessions.",
          empty_body: "Once you sign in, sessions will appear here.",
          summary: {
            zero: "0 active sessions",
            one_other: "{total} active sessions, {others} other",
            many_other: "{total} active sessions, {others} others",
          },
          expires_now: "expiring",
          row: {
            title: "Session {id}",
            subtitle: {
              current: "This session",
              other: "Other session",
            },
            badge: {
              current: "Current",
              active: "Active",
            },
            created: "Created",
            expires: "Expires",
            action: {
              current: "This session",
              disconnect: "Disconnect",
            },
          },
          msg: {
            disconnecting: "Disconnecting session...",
            disconnected: "Session disconnected.",
            disconnect_failed: "Session could not be disconnected.",
            revoking_others: "Disconnecting other sessions...",
            revoked_one: "{n} session disconnected. Current session stays active.",
            revoked_many: "{n} sessions disconnected. Current session stays active.",
            revoke_failed: "Other sessions could not be disconnected.",
          },
        },
        password: {
          title: "Change password",
          hint_required: "Current password is required.",
          hint_optional: "Optional with app login.",
          current: "Current password",
          placeholder_optional: "Optional with app login",
          new: "New password",
          repeat: "Repeat new password",
          save: "Save password",
          msg: {
            enter_current: "Please enter your current password.",
            invalid_length: "New password must be {min}-{max} characters long.",
            mismatch: "New passwords do not match.",
            must_differ: "New password must be different.",
            saving: "Saving password...",
            current_wrong: "Current password is incorrect.",
            reauth_required: "Please sign in again and retry the action.",
            same_password: "New password must not be the same.",
            current_required: "Current password is required.",
            invalid_input: "Please check your input.",
            change_failed: "Password could not be changed.",
            saved: "Password saved.",
            set: "Password set.",
            revoked_one: "{n} other session disconnected.",
            revoked_many: "{n} other sessions disconnected.",
          },
        },
        delete: {
          title: "Delete account",
          desc: "This will permanently delete your account, all monitors and all active sessions.",
          confirm: "Permanently delete account",
          hint_optional: "Optional with app login.",
          msg: {
            enter_current: "Please enter your current password.",
            deleting: "Deleting account...",
            current_wrong: "Current password is incorrect.",
            delete_failed: "Account could not be deleted.",
            deleted: "Account deleted. Redirecting...",
          },
        },
      },
      owner: {
        crumb: "Owner",
        title: "Owner Ops Dashboard",
        sub: "Server load, monitor costs and hotspots in real time",
        badge: "Owner",
        badge_id: "Owner #{id}",
        cards: {
          server_load: {
            title: "Server load",
            sub: "Runtime metrics since process start",
          },
          check_engine: {
            title: "Check engine",
            sub: "Scheduler, throughput and concurrent checks",
          },
          database: {
            title: "Database",
            sub: "Pool utilization and query behavior",
          },
          costs: {
            title: "Most expensive monitors (24h)",
            sub: "Sorted by cost score (checks, response time, errors, timeouts)",
          },
          security: {
            title: "Security insights",
            sub: "Blocks, auth risks and common error patterns",
          },
          db_storage: {
            title: "DB storage history",
            sub: "Database growth and remaining free disk space on the server.",
          },
        },
        table: {
          user: "User",
          status: "Status",
          checks_24h: "Checks (24h)",
          error_rate: "Error rate",
          avg_ms: "Avg ms",
          timeouts: "Timeouts",
          score: "Score",
          no_monitor_data: "No monitor data available.",
        },
        stats: {
          cpu_avg: "CPU avg",
          cpu_p95: "CPU p95",
          event_loop_p95: "Event loop p95",
          rss: "RSS",
          heap_used: "Heap used",
          uptime: "Uptime",
          monitors_active: "Monitors (active)",
          checks_10m: "Checks (10m)",
          failure_rate_10m: "Failure rate (10m)",
          check_p95_duration: "Check p95 duration",
          in_flight: "In flight",
          scheduler_drift_p95: "Scheduler drift p95",
          queries_total: "Total queries",
          slow_queries: "Slow queries",
          db_query_p95: "DB query p95",
          db_ops_active: "Active DB ops",
          acquire_wait_p95: "Acquire wait p95",
          pool_busy: "Pool busy",
          pool_free: "Pool free",
          pool_queue: "Pool queue",
          pool_max_busy: "Pool max busy",
          db_storage_used: "DB used",
          db_storage_growth: "Growth",
          db_storage_server_free: "Server free",
          db_storage_sampled_at: "Last sample",
        },
        value: {
          seconds: "{value} s",
          in_flight: "{current} (max {max})",
        },
        status: {
          paused: "paused",
        },
        security: {
          runtime: "Runtime security counter",
          top_errors: "Top errors (24h)",
          failing_monitors: "Failing monitors (24h)",
          auth: "Auth status",
          invalid_origin_blocked: "Invalid origin blocked: {value}",
          rate_limited_blocked: "Rate limited: {value}",
          oauth_state_rejected: "OAuth state rejected: {value}",
          target_blocked: "Target blocks: {value}",
          block_reason: "Block reason {key}: {value}",
          failing_monitor_line: "{name} ¬∑ User {user} ¬∑ {rate} ({failed}/{total})",
          auth_lockouts: "Active lockouts: {value}",
          auth_failures_24h: "Auth failures (24h): {value}",
          auth_tracked_failures: "Tracked failure records: {value}",
        },
        db_storage: {
          no_data: "No DB storage data available yet.",
          waiting: "Waiting for first samples...",
          footnote: "Window: {hours}h ¬∑ Points: {points} ¬∑ Growth: {growth}",
        },
        email_test: {
          title: "Email Test (Owner)",
          sub: "Send a test email through the configured SMTP account.",
          from: "From",
          to: "To (recipient)",
          template: "Email type",
          template_verification: "Test verification email",
          template_alert_started: "Test alert started email",
          template_alert_resolved: "Test alert resolved email",
          template_label_verification: "Verification email",
          template_label_alert_started: "Alert started",
          template_label_alert_resolved: "Alert resolved",
          subject: "Subject (optional)",
          send: "Send test email",
          send_loading: "Sending...",
          placeholder_to: "your-email@example.com",
          placeholder_subject: "Your PingMyServer verification code",
          smtp_missing: "SMTP is not configured.",
          from_missing: "Not configured",
          config: "SMTP: {host}:{port} ¬∑ {security} ¬∑ {auth}",
          config_security_secure: "SMTPS",
          config_security_starttls: "STARTTLS",
          config_security_plain: "Unencrypted",
          config_auth_none: "no login",
          config_auth_user: "Login {user}",
          msg: {
            enter_recipient: "Please enter a valid recipient email.",
            invalid_template: "Please choose a valid email type.",
            sending: "Sending test email...",
            sent: "Test email ({template}) sent to {to} ({time}).",
            not_configured: "SMTP is not fully configured.",
            invalid_recipient: "Recipient address is invalid.",
            failed: "Email could not be sent.",
          },
        },
      },
      status: {
        h1: "PingMyServer status page",
        brand: {
          title: "Status page",
        },
        unavailable: {
          target: "No monitor selected",
          label: "No monitor available",
          state: "Unavailable",
          hint: "Please open the status page from your dashboard.",
        },
        checking: "Checking status‚Ä¶",
        state: {
          maintenance_running: "Maintenance ongoing",
          operational: "All systems operational",
          outage_detected: "Outage detected",
        },
        duration: {
          online_for: "Online for {duration}",
          offline_for: "Offline for {duration}",
          maintenance_until: "Maintenance until {until} (ends in {remaining})",
        },
        waiting_first_check: "Waiting for first check",
        check_interval: "Check interval: {interval}",
        maintenance: {
          title: "Maintenance",
          planned: "Scheduled",
          active: "Active",
          meta: {
            ends: "{start} ‚Äì {end} ¬∑ ends in {remaining}",
            starts: "{start} ‚Äì {end} ¬∑ starts in {remaining}",
          },
        },
        hero: {
          current_status: "Current status",
          last_check: "Last check",
          last_24h: "Last 24 hours",
        },
        range: {
          last_7_days: "Last 7 days",
          last_30_days: "Last 30 days",
          last_365_days: "Last 365 days",
          choose: "Choose range",
          default: "Last 30 days",
          last_days: "Last {days} days",
          more_soon: "More analytics coming soon",
        },
        incidents: {
          title: "Recent incidents",
          empty_title: "This status page has not recorded any incidents yet.",
          empty_body: "Incidents will appear here once one is detected.",
          footnote: "Shows incidents from the last {days} days.",
        },
        updated_at: "Last updated: ‚Äì",
        updated_at_with_time: "Last updated: {time}",
      },
      game_monitor: {
        title: "Game Monitor",
        sub: "Track game servers live: ping, players and more",
        games: {
          title: "Games",
          minecraft_name: "Minecraft",
          minecraft_note: "Java Edition",
        },
        minecraft: {
          title: "Minecraft Servers",
          sub: "Add servers and track status, ping, players and version.",
        },
        form: {
          name_label: "Server name (optional)",
          name_placeholder: "My Survival Server",
          host_label: "Host or IP",
          host_placeholder: "play.example.net:25565",
          add: "Add server",
        },
        hint_tps: "TPS is often only available if the server exposes it (for example via plugin/RCON).",
        mod: {
          title: "Game Agent Link",
          create_pairing: "Generate verification code",
          sub: "Generate a pairing code on the web and use it in your agent/mod. As long as heartbeats are sent, the connection stays online.",
          code_label: "Current code",
          expires_label: "Valid until",
          sessions_title: "Connected mod sessions",
          sessions_empty_title: "No mod session connected.",
          sessions_empty_body: "Create a pairing code and connect your {game} agent/mod.",
          status_online: "Online",
          status_offline: "Offline",
          status_disconnected: "Disconnected",
          status_revoked: "Revoked",
          revoke: "Disconnect session",
          instance_label: "Instance",
          heartbeat_label: "Last heartbeat",
          mod_version_label: "Mod version",
        },
        empty: {
          title: "No servers yet.",
          body: "Add your first Minecraft server.",
        },
        state: {
          loading: "Refreshing",
          online: "Online",
          offline: "Offline",
        },
        metrics: {
          ping: "Ping",
          tps: "TPS",
          tps_na: "n/a",
          players: "Players",
          version: "Version",
          motd_empty: "No MOTD available.",
          updated: "Updated",
          sample: "Sample players",
        },
        dashboard: {
          crumb: "Game Monitoring",
          header_subtitle: "Live overview for your Minecraft mod connection",
          updated_fallback: "Last update: --",
          updated_at: "Last update: {time}",
          create_pairing: "Generate verification code",
          server_name_fallback: "Minecraft Mod Monitor",
          status: {
            online: "Online",
            degraded: "Degraded",
            offline: "Offline",
            not_connected: "Not connected",
          },
          connection: {
            title: "Minecraft Mod Connection",
            sub: "Use the pairing code in your mod. As soon as heartbeats arrive, live metrics are shown automatically.",
            code_label: "Current code",
            expires_label: "Valid until",
            no_code: "No active code",
          },
          kpis: {
            title: "Server KPIs",
            current_tps: "Current TPS",
            online_players: "Online Players",
            average_ping: "Average Ping",
            cpu_usage: "CPU Usage",
            memory_usage: "Memory Usage",
            uptime: "Uptime (24h)",
          },
          health: {
            title: "Overall Health",
            description: "Calculated from TPS, session status and latency ({online}/{total} online)",
          },
          trend: {
            waiting: "Waiting for data",
            vs_recent: "vs recent samples",
            live_value: "Live from mod metrics",
          },
          charts: {
            tps_title: "TPS over time",
            players_title: "Players over time",
          },
          chart_stats: {
            minimum: "Minimum",
            maximum: "Maximum",
            current: "Current",
            peak: "Peak",
            average: "Average",
          },
          live_metrics: {
            title: "Live Server Metrics",
            rows: {
              tps: "TPS",
              tps_extra: "Directly from mod metrics",
              ping: "Average Ping",
              ping_extra: "Mean across active sessions",
              players: "Players",
              players_extra: "Online / Max",
              sessions: "Sessions",
              sessions_extra: "Online / Total",
              version: "Server Version",
              version_extra: "Version from mod heartbeat",
              world: "World",
              world_extra: "If provided by the mod",
              dimension: "Dimension",
              dimension_extra: "If provided by the mod",
              motd: "MOTD",
              motd_extra: "Current MOTD text",
              mod_version: "Mod Version",
              mod_version_extra: "Reported by connected session",
              instance: "Instance",
              instance_extra: "Unique session ID",
              heartbeat: "Last Heartbeat",
              heartbeat_extra: "Timestamp of latest heartbeat",
              cpu: "CPU Usage",
              cpu_extra: "Average across active sessions",
              memory: "Memory Usage",
              memory_extra: "Aggregated across active sessions",
              packet_loss: "Packet Loss",
              packet_loss_extra: "Average percentage",
            },
          },
          events: {
            title: "Events / Incidents",
            new_session: "New session detected: {session}",
            session_recovered: "Session back online: {session}",
            session_stale: "Heartbeat stale/offline: {session}",
            session_removed: "Session removed/disconnected: {session}",
            no_changes: "No session status changes detected yet.",
            type_restart: "RESTART",
            type_error: "ERROR",
            type_disconnect: "DISCONNECT",
            type_connect: "CONNECT",
            type_warning: "WARNING",
            type_info: "INFO",
          },
          sessions: {
            title: "Mod Sessions",
            empty_body: "Create a pairing code and connect your Minecraft server with the mod.",
            world: "World",
          },
          plugins: {
            title: "Mods & Plugins",
            empty: "No plugin data received from the mod yet.",
            summary_count: "{count} plugins detected",
            enabled: "Enabled",
            disabled: "Disabled",
            version_unknown: "Version unknown",
          },
          latency: {
            title: "Latency by Region",
            empty: "No regional latency values available yet.",
            summary_count: "{count} regions",
          },
          discord: {
            title: "Discord Integration",
            channel: "#server-status",
            status_label: "Status",
            test_button: "Send test alert",
            settings_link: "Open settings",
            status_loading: "Loading",
            status_loading_desc: "Loading Discord configuration.",
            status_not_configured: "Not configured",
            not_configured_desc: "Configure a Discord webhook in Connections.",
            status_enabled: "Enabled",
            enabled_desc: "Alerts are active ({webhook})",
            status_disabled: "Disabled",
            disabled_desc: "Webhook configured, but alerts are disabled ({webhook})",
            test_sent: "Discord test alert sent.",
            test_failed: "Could not send Discord test alert.",
          },
          insight: {
            title: "AI Insight",
            no_data_1: "No mod session connected yet. Generate a pairing code and connect your server.",
            no_data_2: "As soon as heartbeats arrive, this section will show hints about TPS, ping and session stability.",
            stable_tps: "TPS is stable near 20. Tick performance currently looks healthy.",
            low_tps: "TPS is at {tps}. Watch load spikes.",
            waiting_tps: "The mod is not sending TPS values yet.",
            high_ping: "Ping is elevated at {ping} ms. Check network path and host load.",
            partial_online: "{online} of {total} sessions are online.",
            healthy: "All connected sessions are sending heartbeats regularly.",
          },
        },
        messages: {
          invalid_address: "Please enter a valid host.",
          duplicate: "Server is already in the list.",
          limit: "Maximum {count} servers allowed.",
          added: "Server added.",
          removed: "Server removed.",
          refreshed: "Live data refreshed.",
          pairing_created: "Pairing code created.",
          pairing_failed: "Failed to create code.",
          session_revoked: "Session disconnected.",
          session_revoke_failed: "Failed to disconnect session.",
          remove_game_confirm: "Remove game \"{game}\"?",
          remove_game_success: "Game \"{game}\" removed.",
          remove_game_failed: "Game could not be removed.",
          remove_game_blocked: "This game cannot be removed.",
          direct_probe_unavailable: "Direct server probing is currently available for Minecraft only. Use the agent link for {game}.",
        },
        error_codes: {
          dns_not_found: "DNS could not be resolved.",
          connection_refused: "Connection was refused by the server.",
          timeout: "Server did not respond in time.",
          unreachable: "Server is unreachable.",
          invalid_status: "Received invalid status response.",
          connection_closed: "Connection closed too early.",
          request_failed: "Status request failed.",
          connection_failed: "Connection failed.",
          probe_failed: "Server probe failed.",
          target_blocked: "Target is blocked by security policy.",
          invalid_input: "Input is invalid.",
          unauthorized: "Session expired. Please sign in again.",
        },
      },
      common: {
        language: "Language",
        lang_de: "German",
        lang_en: "English",
        aria: {
          home: "PingMyServer homepage",
          profile_settings: "Connections and account settings",
        },
        account: "Account",
        legal: "Legal",
        terms: "Terms",
        privacy: "Privacy",
        imprint: "Imprint",
        back_home: "Back to home",
        status_page: "Status page",
        monitoring: "Monitoring",
        monitors: "Monitors",
        monitor: "Monitor",
        location: "Location",
        aggregate: "Overall",
        interval: "Interval",
        new_monitor: "New monitor",
        public_status_page: "Public status page",
        save: "Save",
        refresh: "Refresh",
        asc: "Ascending",
        desc: "Descending",
        incidents: "Incidents",
        notifications: "Notifications",
        game_monitor: "Game Monitor",
        connections: "Connections",
        owner_ops: "Owner Ops",
        your_monitors: "Your monitors",
        signed_in: "signed in",
        logout: "Log out",
        loading: "Loading‚Ä¶",
        loading_data: "Loading...",
        please_wait: "Please wait.",
        error_loading: "Failed to load.",
        try_again: "Please try again.",
        try_again_later: "Please try again later.",
        no_data: "No data",
        no_data_available: "No data available.",
        not_available: "n/a",
        unknown: "unknown",
        none: "none",
        delete: "Delete",
        cancel: "Cancel",
        connection_failed: "Connection failed.",
      },
    },
  };

  function normalizeLang(value) {
    const raw = String(value || "").trim().toLowerCase();
    if (!raw) return DEFAULT_LANG;
    if (raw === "de" || raw.startsWith("de-")) return "de";
    if (raw === "en" || raw.startsWith("en-")) return "en";
    return DEFAULT_LANG;
  }

  function detectLang() {
    try {
      const params = new URLSearchParams(window.location.search || "");
      const fromQuery = params.get("lang");
      if (fromQuery) return normalizeLang(fromQuery);
    } catch {
      // ignore
    }

    try {
      const stored = window.localStorage.getItem(STORAGE_KEY);
      if (stored) return normalizeLang(stored);
    } catch {
      // ignore
    }

    return normalizeLang(navigator.language || DEFAULT_LANG);
  }

  function deepGet(obj, path) {
    const parts = String(path || "").split(".").filter(Boolean);
    let cur = obj;
    for (const part of parts) {
      if (!cur || typeof cur !== "object") return undefined;
      cur = cur[part];
    }
    return cur;
  }

  function interpolate(template, vars) {
    if (!template) return "";
    if (!vars) return template;
    return String(template).replace(/\{([a-zA-Z0-9_]+)\}/g, (match, name) => {
      if (vars[name] === undefined || vars[name] === null) return match;
      return String(vars[name]);
    });
  }

  let currentLang = detectLang();
  if (!SUPPORTED.has(currentLang)) currentLang = DEFAULT_LANG;

  function getLang() {
    return currentLang;
  }

  function locale() {
    return LOCALE_MAP[currentLang] || LOCALE_MAP[DEFAULT_LANG] || "de-DE";
  }

  function t(key, vars, fallback) {
    const primary = deepGet(STRINGS[currentLang], key);
    const secondary = deepGet(STRINGS[DEFAULT_LANG], key);
    const value =
      typeof primary === "string"
        ? primary
        : typeof secondary === "string"
          ? secondary
          : typeof fallback === "string"
            ? fallback
            : "";
    return interpolate(value, vars);
  }

  let cachedRtfLocale = null;
  let cachedRtf = null;

  function getRtf() {
    const loc = locale();
    if (cachedRtf && cachedRtfLocale === loc) return cachedRtf;
    cachedRtfLocale = loc;
    cachedRtf = new Intl.RelativeTimeFormat(loc, { numeric: "auto" });
    return cachedRtf;
  }

  function applyTranslations(root = document) {
    document.documentElement.setAttribute("lang", currentLang);
    document.documentElement.setAttribute("data-lang", currentLang);

    for (const el of root.querySelectorAll("[data-lang-block]")) {
      const blockLang = normalizeLang(el.getAttribute("data-lang-block"));
      el.hidden = blockLang !== currentLang;
    }

    for (const el of root.querySelectorAll("[data-i18n]")) {
      const key = el.getAttribute("data-i18n");
      const value = t(key, null, "");
      if (value) el.textContent = value;
    }

    for (const el of root.querySelectorAll("[data-i18n-placeholder]")) {
      const key = el.getAttribute("data-i18n-placeholder");
      const value = t(key, null, "");
      if (value) el.setAttribute("placeholder", value);
    }

    for (const el of root.querySelectorAll("[data-i18n-title]")) {
      const key = el.getAttribute("data-i18n-title");
      const value = t(key, null, "");
      if (value) el.setAttribute("title", value);
    }

    for (const el of root.querySelectorAll("[data-i18n-alt]")) {
      const key = el.getAttribute("data-i18n-alt");
      const value = t(key, null, "");
      if (value) el.setAttribute("alt", value);
    }

    for (const el of root.querySelectorAll("[data-i18n-aria-label]")) {
      const key = el.getAttribute("data-i18n-aria-label");
      const value = t(key, null, "");
      if (value) el.setAttribute("aria-label", value);
    }

    for (const el of root.querySelectorAll("[data-i18n-content]")) {
      const key = el.getAttribute("data-i18n-content");
      const value = t(key, null, "");
      if (value) el.setAttribute("content", value);
    }
  }

  function bindLanguageSelectors(root = document) {
    for (const select of root.querySelectorAll("select[data-lang-select]")) {
      try {
        select.value = currentLang;
      } catch {
        // ignore
      }

      select.addEventListener("change", () => {
        const next = normalizeLang(select.value);
        setLang(next, { reload: true });
      });
    }

    for (const btn of root.querySelectorAll("[data-set-lang]")) {
      btn.addEventListener("click", () => {
        const next = normalizeLang(btn.getAttribute("data-set-lang"));
        setLang(next, { reload: true });
      });
    }
  }

  function setLang(nextLang, options = {}) {
    const { persist = true, reload = true } = options;
    const normalized = normalizeLang(nextLang);
    if (!SUPPORTED.has(normalized)) return;
    currentLang = normalized;

    if (persist) {
      try {
        window.localStorage.setItem(STORAGE_KEY, currentLang);
      } catch {
        // ignore
      }
    }

    applyTranslations(document);

    if (reload) {
      try {
        const url = new URL(window.location.href);
        if (url.searchParams.get("lang")) {
          url.searchParams.set("lang", currentLang);
          window.location.replace(url.toString());
          return;
        }
      } catch {
        // ignore
      }
      window.location.reload();
    }
  }

  function init() {
    applyTranslations(document);
    bindLanguageSelectors(document);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init, { once: true });
  } else {
    init();
  }

  window.PMS_I18N = {
    STRINGS,
    t,
    locale,
    getLang,
    setLang,
    applyTranslations,
    rtf: getRtf,
  };
})();



